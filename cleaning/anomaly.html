<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Title -->
    <title>Cleaning Data for Effective Data Science</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">
    <!-- Font awesome CSS -->
    <link rel="stylesheet" href="assets/css/font-awesome.min.css">
    <!-- Animate CSS -->
    <link rel="stylesheet" href="assets/css/animate.min.css">
    <!-- Main CSS -->
    <link rel="stylesheet" href="style.css">
    <!-- Responsive CSS -->
    <link rel="stylesheet" href="assets/css/responsive.css">
    <!-- jQuery -->
    <script src="assets/js/jquery-1.11.3.min.js"></script>
    <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML-full,Safe">
    </script>
</head>

<body>
    <!--left bar area-->
    <div class="left-bar-area">
        <div class="logo">
            <a href="index.html">
                <img src="img/home.png" alt="Home" width="50px" /></a>
            <div class="menu-switch">
                <span class="menu-bar-one"></span>
                <span class="menu-bar-two"></span>
                <span class="menu-bar-three"></span>
            </div>
        </div>

        <div class="social">
            <a href="https://gnosis.cx/publish/">
                <img src="img/DQM-Mohawk-head.jpg" alt="David Mertz Publications"></a>
            <a href="https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291">
                <img src="img/packt-squarelogo.png" alt="Buy from Packt"></a>
            <a href="https://www.amazon.com/Cleaning-Data-Effective-Science-command-line/dp/1801071292">
                <img src="https://i.pinimg.com/originals/29/f6/41/29f641b507ccb60bb7a62a830b988736.jpg"
                    alt="Buy from Amazon"></a>
        </div>
    </div>

    <!--Nav Menu Start -->
    <nav class="mainmenu">
        <ul>
            <li><a href="preface.html">Preface</a></li>
            <li><a href="tabular.html">Tabular Formats</a></li>
            <li><a href="hierarchical.html">Hierarchical Formats</a></li>
            <li><a href="repurposing.html">Repurposing Data Sources</a></li>
            <li><a href="anomaly.html">Anomaly Detection</a></li>
            <li><a href="data-quality.html">Data Quality</a></li>
            <li><a href="value-imputation.html">Value Imputation</a></li>
            <li><a href="feature-engineering.html">Feature Engineering</a></li>
            <li><a href="closure.html">Closure</a></li>
            <li><a href="glossary.html">Glossary</a></li>
        </ul>
    </nav>

    <!--Services Area Start-->
    <nav class="navigation" id="mainNav">
        <a class="navigation__link" onclick="bookText('1')">Introduction</a>
        <a class="navigation__link" onclick="bookText('2')">Missing Data</a>
        <a class="navigation__link sub" onclick="bookText('2-1')">SQL</a>
        <a class="navigation__link sub" onclick="bookText('2-2')">Hierarchical Formats</a>
        <a class="navigation__link sub" onclick="bookText('2-3')">Sentinels</a>
        <a class="navigation__link" onclick="bookText('3')">Miscoded Data</a>
        <a class="navigation__link" onclick="bookText('4')">Fixed Bounds</a>
        <a class="navigation__link" onclick="bookText('5')">Outliers</a>
        <a class="navigation__link sub" onclick="bookText('5-1')">Z-Score</a>
        <a class="navigation__link sub" onclick="bookText('5-2')">Interquartile Range</a>
        <a class="navigation__link" onclick="bookText('6')">Multivariate Outliers</a>
        <a class="navigation__link" onclick="bookText('buy')">Exercises</a>
        <a class="navigation__link sub" onclick="bookText('buy')">A Famous Experiment</a>
        <a class="navigation__link sub" onclick="bookText('buy')">Misspelled Words</a>
        <a class="navigation__link" onclick="bookText('8')">Denouement</a>
    </nav>
    <!-- Service Area End -->

    <div class="container shift-right">
        <div class="row">
            <div class="col-md-9" id="book-title"></div>
            <div class="col-md-9">
                <h1>Anomaly Detection</h1>
            </div>
        </div>

        <div class="row">
            <div class="col-md-9">
                <blockquote>
                    <p>The map is not the territory and data is not the world observed.
                        Data is messy, inconsistent, and unreliable. The world is messier,
                        less consistent, and less reliable.<br />–c.f. Alfred Korzybski.</p>
                </blockquote>
            </div>
            <div class="col-md-9">
                <div class="hidden" id="book-text"></div>
            </div>
        </div>
        <footer>
            <p>© 2021 Packt Publishing</p>
        </footer>

    </div>

    <div class="hidden" id="1">
        <h2>Introduction</h2>

        <p>When we think about anomaly detection, there are two distinct, and mostly independent, concepts that go by
            the
            name. The topic of this chapter is perhaps the less exciting of the two. Security and cryptography
            researchers,
            importantly, look for anomalies that can represent fraud, forgery, and system intrusion attempts. By the
            intention of perpetrators, these outliers in the normal patterns of data are subtle and hard to detect, and
            a
            conflict exists between those wishing to falsify data and those wishing to detect that falsification.</p>

        <p>The concept of interest to us in this book is more quotidian. We wish to detect those cases where data goes
            bad
            in the ordinary course of its collection, collation, transmission, and transcription. Perhaps an instrument
            gives a bad reading some or all of the time. Perhaps some values are systematically altered in the course of
            reencoding to a different data format. Perhaps the wrong units of measure were used for a subset of the
            data.
            And so on. By accident, these broader checks may occasionally identify changes that reflect actual malice,
            but
            more often they will simply detect errors, and <em>perhaps</em> bias (but less often, since bias still is
            usually towards <em>plausible</em> values).</p>

        <p>Anomaly detection has an especially close connection to chapter 5 (<em>Data Quality</em>), and often to the
            topic
            of chapter 6 (<em>Value Imputation</em>). The loose contrast between this chapter and the next one on data
            quality is that anomalies are individual data values that can be diagnosed as probably wrong, whereas data
            quality more broadly looks at <em>patterns</em> of the data set as a whole that can present or identify
            problems. When anomalies <em>are</em> detected it sometimes makes sense to impute more likely values rather
            than
            discard those observations altogether. In terms of the structure of this book, the lessons of this chapter
            will
            allow you to identify and mark anomalies as "missing" while chapter 6 will pick up with filling in those
            better
            imputed values (imputation is simply replacing missing data points with values that are likely, or at least
            plausible).</p>

        <p>These connected chapters—4 5, and 6—form a broader unit, and roughly describe a pipeline or series of steps.
            That
            is, given your inevitably flawed data you might first look for anomalies and mark them missing. Next you
            might
            look for more systematic attributes of your data set, and remediate them in various ways. Finally, you might
            impute (or drop) data that was either missing to start with or marked so because of properties this chapter
            will
            help you detect. The step past the final step of this sequence is the actual modeling or analysis you
            perform,
            and is the subject of many excellent books, but not of this one.<sup><i>cleancode</i></sup></p>

        <div class="note">
            <i>cleancode</i><br />
            My mention of these steps is a good opportunity to repeat an admonishment that has occurred elsewhere
            herein. The
            steps of your data processing pipeline should be coded and documented carefully and reproducibly. It is
            often easy
            and tempting to make changes to data sets in an exploratory way—as this book does—but in the process lose a
            good
            record of exactly what steps were taken. The exploration is an integral part of data science, but
            reproducibility
            should not be lost in that process. Good practice is to retain your original data set—in whatever data
            format it
            originally presents itself—and generate the final version via scripts (maintained in version control) rather
            than
            within notebooks or interactive shells. Care must always be taken to allow someone else to repeatably move
            from the
            raw original data set to the version that is fed into a machine learning model or other analytic tool.
            Keeping an
            audit trail of what tool or function produced what change is hygenic practice.
        </div>

        <hr>
        <p>Before we get to the sections of this chapter, let us run our standard setup code.</p>


        <pre class="input">from src.setup import *
%load_ext rpy2.ipython
</pre>


        <pre class="input">%%capture --no-stdout err
%%R
library(tidyverse)
require(&quot;RPostgreSQL&quot;)
</pre>

    </div>
    <div class="hidden" id="2">
        <h2>Missing Data</h2>

        <blockquote>
            <p>Gregory: Is there any other point to which you would wish to draw my attention?<br />
                Holmes: To the curious incident of the dog in the night-time.<br />
                Gregory: The dog did nothing in the night-time.<br />
                Holmes: That was the curious incident.<br />–Arthur Conan Doyle</p>
        </blockquote>

        <p><strong>Concepts</strong>:</p>
        <ul>
            <li>Sentinels versus explicit absence</li>
            <li>Semantics of NULL, NaN, and N/A</li>
            <li>Nullable columns in SQL</li>
            <li>Absence in hierarchies</li>
            <li>Pitfalls of sentinels</li>
        </ul>

        <p>Some data formats explicitly support missing data while other formats use a special values, known as a
            sentinel
            value, of one sort or another to indicate missingness. Non-tabular formats may indicate missing data simply
            by
            not including any value in a position where it might otherwise occur. However, sentinel values are sometimes
            ambiguous, unfortunately.</p>

        <p>In particular, within many data formats, and within most data frame libraries, missing numeric values are
            represented by the special IEEE-754 floating-point value NaN (Not-a-Number). The problem here is that NaN,
            by
            design and intention, can arise as the result of some attempts at computation that are not obviously
            unreasonable. While such an unrepresentable value is indeed <em>unavailable</em>, this is potentially
            semantically different from data that was simply never collected in the first place. As a small digression,
            let
            us look at coaxing a NaN to arise in an "ordinary" computation (albeit a contrived one).</p>


        <pre class="input">for n in range(7, 10):
    exp1 = 2**n
    a = (22/7) ** exp1 
    b = π ** exp1
    # Compute answer in two &quot;equivalent&quot; ways
    res1 = (a * a) / (b * b)
    res2 = (a / b) * (a / b)
    print(f&quot;n={n}:\n  &quot;
          f&quot;method1: {res1:.3f}\n  &quot;
          f&quot;method2: {res2:.3f}&quot;)
</pre>

        <pre>n=7:
  method1: 1.109
  method2: 1.109
n=8:
  method1: 1.229
  method2: 1.229
n=9:
  method1: nan
  method2: 1.510
</pre>

        <p>Parallel to the pitfall of missing floats being represented as NaNs, missing strings are almost always
            represented as <em>strings</em>. Generally, one or more reserved values such as 'N/A' or the empty string
            are
            used when a string value is missing. However, those sentinels do not clearly distinguish between "not
            applicable" and "not available" which are subtly different.</p>

        <p>As a toy example, we might have collected names of people, including "middle name." Having a sentinel value
            for
            middle name would not distinguish between survey subjects who have no middle name and those who merely had
            not
            provided it. Reaching just slightly for a data science purpose: perhaps we wish to find the correlation
            between
            certain middle names and demographic characteristics. In the United States, for example, the middle name
            "Santiago" would be strongly associated with Hispanic family origin; a survey subject who provided no middle
            name might nonetheless have that middle name. In principle, a string field could contain different sentinels
            for, e.g. "No middle name" and "No response" but data sets are <em>very rarely</em> careful in those
            distinctions.</p>

    </div>
    <div class="hidden" id="2-1">
        <h3>SQL</h3>

        <p>In SQL databases, an explicit NULL is available for all column types. Whether a particular column is
            "nullable"
            is determined by the database administrator (or whoever had that functional role, however much or little
            qualified). This allows a distinction in principle between an explicit NaN for a numeric field and a NULL
            for
            missing values.</p>

        <p>Unfortunately, many or most actual database tables fail to utilize these available distinctions (i.e. the
            specific configured and populated tables). In practice, you are likely to see many combinations of empty
            strings, NaNs, actual NULLs, or other sentinels, even within SQL databases. This is not because any widely
            used
            RDBMS fails to support these different values and types, it is rather that in the history of various clients
            putting data into them, using various codebases, non-optimal choices were made.</p>

        <p>To run the code in the next cells, you need to obtain access to an RDBMS. The PostgreSQL server running on my
            local system, in particular, has a database called <code>dirty</code>, and that in turn contains a table
            called
            <code>missing</code>. If you use a different RDBMS, your driver will have a different name, and your engine
            will
            use a different scheme in its connection URL. The particular user, password, host, and port will also vary.
            Database servers also often use authentication methods other than a password to grant access. However, the
            Python DB-API (<em>database API</em>) is quite consistent, and you will work with the connection object and
            engine in identical ways when you access other RDBMS's. For illustrative purposes, we show the PostgreSQL
            configuration function <code>connect_local()</code> which is contained in <code>setup.py</code>.
        </p>


        <pre class="input"># PostgreSQL configuration
def connect_local():
    user = &#39;cleaning&#39;
    pwd = &#39;data&#39;
    host = &#39;localhost&#39;
    port = &#39;5432&#39;  
    db = &#39;dirty&#39;
    con = psycopg2.connect(database=db, host=host, user=user, password=pwd)
    engine = create_engine(f&#39;postgresql://{user}:{pwd}@{host}:{port}/{db}&#39;)
    return con, engine
</pre>

        <p>With the connection established, we can examine some of our data in Python.</p>


        <pre class="input">con, engine = connect_local()
cur = con.cursor()
# Look at table named &quot;missing&quot;
cur.execute(&quot;SELECT * FROM missing&quot;)
for n, (a, b) in enumerate(cur):
    print(f&quot;{n+1} | {str(a):&gt;4s} | {b}&quot;)
</pre>

        <pre>1 |  nan | Not number
2 | 1.23 | A number  
3 | None | A null    
4 | 3.45 | Santiago  
5 | 6.78 |           
6 | 9.01 | None
</pre>

        <p>As Python objects, an SQL NULL is represented as the singleton None, which is a reasonable choice. Let us
            review
            this friendly data representation.</p>
        <ul>
            <li>Row 1 contains a NaN (not computable) and a string describing the row;</li>
            <li>Row 2 contains a regular float value and a string describing it;</li>
            <li>Row 3 contains an SQL NULL (not available) and a string;</li>
            <li>Row 4 contains a regular float value and a regular string;</li>
            <li>Row 5 contains a regular float value and an empty string ("not applicable");</li>
            <li>Row 6 contains a regular float value and a NULL ("not available").</li>
        </ul>

        <p>In terms of actually supporting the distinction between a true NULL and a sentinel value like NaN, libraries
            are
            of mixed quality. Pandas has made some strides with version 1.0 by introducing the special singleton
            <code>pd.NA</code> to be used as a "missing" indicator across data types, instead of <code>np.nan</code>,
            <code>None</code>, and <code>pd.NaT</code> (Not a Time). However, as of this writing, the singleton is not
            utilized in any of the standard data readers, and getting the value into data requires special efforts. I
            hope
            this will have improved by the time you read this. R's Tidyverse does better because R itself has an
            <code>NA</code> special value. Slightly confusingly, R also contains an <em>even more special</em>
            pseudo-value
            <code>NULL</code> which is used to indicate that something is undefined (as opposed to simply missing). R's
            NULL
            can result from some expressions and function calls, but it cannot be an element in arrays or data frames.
        </p>


        <pre class="input">%%R
# Notice NULL is simply ignored in the construction
tibble(val = c(NULL, NA, NaN, 0), 
       str = c(&quot;this&quot;, &quot;that&quot;, NA))
</pre>

        <pre># A tibble: 3 x 2
    val str  
  &lt;dbl&gt; &lt;chr&gt;
1    NA this 
2   NaN that 
3     0 NA   
</pre>

        <p>What SQL calls NULL, R calls NA; NaN remains a separate value indicating "not
            computable."<sup><i>NaN</i></sup>
            This allows R to interface correctly and unambiguously with SQL, or with the occasional other formats which
            also
            explicitly mark "missing" in a non-sentinel manner.</p>

        <div class="note">
            <i>NaN</i><br />
            The IEEE-754 standard, in fact, reserves a large number of bit patterns as NaNs: 16 million of them for
            32-bit
            floats, and vastly more for 64-bit floats. Moreover, these many NaNs are divided into a generous number each
            for
            *signaling* versus *quiet* NaNs. In concept, when the standard was developed, the choice of which of the
            millions of
            NaNs available (the "payload") could be used to record information about exactly what kind of operation led
            to the
            NaN occurring. That said, no software used in data science—and nearly no software used in array and numeric
            computation—actually utilizes the distinction among the many NaNs. In practical terms, NaN is equivalent to
            a
            singleton, like R's <code>NA</code>, Python's <code>None</code>, or Javascript's <code>null</code>.
        </div>

        <p>This R code assumes the same PostgreSQL database is available as that used in the Python example. As with the
            Python code, a different RDBMS will require a different driver name, and user, password, host, and port will
            vary in your configuration.</p>


        <pre class="input">%%R
drv &lt;- dbDriver(&quot;PostgreSQL&quot;)
con &lt;- dbConnect(drv, dbname = &quot;dirty&quot;,
                 host = &quot;localhost&quot;, port = 5432,
                 user = &quot;cleaning&quot;, password = &quot;data&quot;)
sql &lt;- &quot;SELECT * FROM missing&quot;
data &lt;- tibble(dbGetQuery(con, sql))
data
</pre>

        <pre># A tibble: 6 x 2
       a b           
   &lt;dbl&gt; &lt;chr&gt;       
1 NaN    &#34;Not number&#34;
2   1.23 &#34;A number  &#34;
3  NA    &#34;A null    &#34;
4   3.45 &#34;Santiago  &#34;
5   6.78 &#34;          &#34;
6   9.01  NA         
</pre>

        <p>In contrast, Pandas 1.0 produces the less correct data frame. The <code>engine</code> object was configured
            and
            discussed above with the <code>connect_local()</code> function.</p>


        <pre class="input">pd.read_sql(&quot;SELECT * FROM missing&quot;, engine)
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>a</th>
                    <th>b</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>NaN</td>
                    <td>Not number</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>1.23</td>
                    <td>A number</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>NaN</td>
                    <td>A null</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>3.45</td>
                    <td>Santiago</td>
                </tr>
                <tr>
                    <th>4</th>
                    <td>6.78</td>
                    <td></td>
                </tr>
                <tr>
                    <th>5</th>
                    <td>9.01</td>
                    <td>None</td>
                </tr>
            </tbody>
        </table>

    </div>
    <div class="hidden" id="2-2">
        <h3>Hierarchical Formats</h3>
        <p>In formats like JSON that nest data flexibly, there is an obvious way of representing missing data: by not
            representing it at all. If you perform hierarchical processing, you will need to check for the presence or
            absence of a given dictionary key at a given level. The JSON specification itself does not address NaN
            values,
            which means that some systems producing data may choose to use the Javascript <code>null</code> value in its
            place, producing the ambiguity we have discussed above. However, many specific libraries extend the
            definition
            to recognize NaN (and sometimes <code>inf</code>, which is also a floating-point number) as a value. To
            illustrate:</p>


        <pre class="input">json.loads(&#39;[NaN, null, Infinity]&#39;)  # null becomes Python None
</pre>


        <pre>[nan, None, inf]</pre>

        <p>Let us represent the same data of the SQL table illustrated above in a (relatively) compact way. Notice,
            however,
            that since in the Python <code>json</code> library NaN is a recognized value, we <em>could</em> explicitly
            represent all missing keys and match them with <code>null</code> as needed. Obviously, we data scientists do
            not
            usually generate the data we need to consume; so the format we get is the one we need to process.</p>

        <p>We can read this particular data into a Pandas DataFrame easily, subject to the sentinel limitation. Since a
            data
            frame imposes a tabular format, the missing row/column positions must be filled with some value, in this
            case
            with a NaN as sentinel. Of course, as discussed in chapter 2 (<em>Data Ingestion – Hierarchical
                Formats</em>),
            nested data may simply not be amenable to being represented in a tabular way.</p>


        <pre class="input">json_data = &#39;&#39;&#39;
{&quot;a&quot;: {&quot;1&quot;: NaN, &quot;2&quot;: 1.23, &quot;4&quot;: 3.45, &quot;5&quot;: 6.78, &quot;6&quot;: 9.01},
 &quot;b&quot;: {&quot;1&quot;: &quot;Not number&quot;, &quot;2&quot;: &quot;A number&quot;, &quot;3&quot;: &quot;A null&quot;,
       &quot;4&quot;: &quot;Santiago&quot;, &quot;5&quot;: &quot;&quot;}
}&#39;&#39;&#39;
</pre>


        <pre class="input">pd.read_json(json_data).sort_index()
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>a</th>
                    <th>b</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>1</th>
                    <td>NaN</td>
                    <td>Not number</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>1.23</td>
                    <td>A number</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>NaN</td>
                    <td>A null</td>
                </tr>
                <tr>
                    <th>4</th>
                    <td>3.45</td>
                    <td>Santiago</td>
                </tr>
                <tr>
                    <th>5</th>
                    <td>6.78</td>
                    <td></td>
                </tr>
                <tr>
                    <th>6</th>
                    <td>9.01</td>
                    <td>NaN</td>
                </tr>
            </tbody>
        </table>

        <p>Let us also process this JSON data in a more hierarchical and procedural way for illustration, classifying
            special/missing values as we encounter them. For the example, we assume that the top level is a dictionary
            of
            dictionaries, but obviously we could walk other structures as well if needed.</p>


        <pre class="input">data = json.loads(json_data)
rows = {row for dct in data.values() 
            for row in dct.keys()}

for row in sorted(rows):
    for col in data.keys():
        val = data[col].get(row)
        if val is None:
            print(f&quot;Row {row}, Col {col}: Missing&quot;)
        elif isinstance(val, float) and math.isnan(val):
            print(f&quot;Row {row}, Col {col}: Not a Number&quot;)
        elif not val:
            print(f&quot;Row {row}, Col {col}: Empty value {repr(val)}&quot;)
</pre>

        <pre>Row 1, Col a: Not a Number
Row 3, Col a: Missing
Row 5, Col b: Empty value &#39;&#39;
Row 6, Col b: Missing
</pre>

    </div>
    <div class="hidden" id="2-3">
        <h3>Sentinels</h3>

        <p>In textual data formats, mainly delimited and fixed width files, missing data is indicated either by absence
            or
            by a sentinel. Both delimited and fixed width formats are able to omit a certain field in a row—albeit, in
            fixed
            width, this does not distinguish among an empty string, a string of spaces, and a missing value. Two commas
            next
            to each other in CSV should be unambiguous for "no value." Ideally, this absence should be used to indicate
            missingness, and potentially allow some other sentinel to indicate "Not Applicable", "Not Calculable", "No
            Middle Name", or other specific markers for known values that fall outside the domain of a variable. In
            practice, however, the "best practice" I recommend here is often not what is used in the data sets you will
            actually need to work with.</p>

        <p>Use of sentinels is not limited to text formats. Often in SQL, for example, TEXT or CHAR columns that could,
            in
            principle, be made nullable and use NULL to indicate mising values instead use sentinels (and not always
            single
            sentinels; in practice they often acquire multiple markers over multiple generations of software changes).
            Sometimes formats such as JSON that can hold text values likewise use sentinels rather than omitting keys.
            Even
            in formats like HDF5 that enforce data typing, sometimes sentinel numeric values are used to indicate
            missing
            values rather than relying on NaN as a special marker (which has its own problems, discussed above).</p>

        <p>In Pandas, in particular, as of version 1.0, the following sentinel values are recognized by default as
            meaning
            "missing" when reading delimited or fixed width files: '', '#N/A', '#N/A N/A', '#NA', '-1.#IND', '-1.#QNAN',
            '-NaN', '-nan', '1.#IND', '1.#QNAN', '<NA>', 'N/A', 'NA', 'NULL', 'NaN', 'n/a', 'nan', 'null'. Some of these
                must arise in domains or from tools I am personally unfamiliar with, but many I have seen. However, I
                have
                also encountered numerous sentinels not in that list. You will need to consider sentinels for your
                specific
                data set, and such defaults are only some first guesses the tool provides. Other tools will have
                different
                defaults.</p>

        <p>Libraries for working with data sets, often as data frames, will have mechanisms to specify the particular
            values
            to treat as sentinels for missing data. Let us look at an example that is closely based on real-world data
            obtained from the United States National Oceanic and Atmospheric Administration (NOAA). This data was, in
            fact,
            provided as CSV files; a more descriptive filename is used here, and many of the columns are omitted. But
            only
            one data value is changed in the example. In other words, this is a data set I actually had to work with
            outside
            of writing this book, and the issues discussed were not ones I knew about in advance of doing that.</p>

        <p>The data set we read below concerns weather measurements at a particular weather station. The station at
            Sorstokken, Norway, is chosen here more-or-less at random from thousands available. Others stations employ
            the
            same encoding, which is nowhere obviously documented. Unfortunately, undocumented or underdocumented field
            contraints are the rule in published data, not the exception. The column names are somewhat abbreviated, but
            not
            too hard to guess the meaning of: temperature (℉), maximum wind gust speed (mph), etc.</p>


        <pre class="input">sorstokken = pd.read_csv(&#39;data/sorstokken-no.csv.gz&#39;)
sorstokken
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>STATION</th>
                    <th>DATE</th>
                    <th>TEMP</th>
                    <th>VISIB</th>
                    <th>GUST</th>
                    <th>DEWP</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>1001499999</td>
                    <td>2019-01-01</td>
                    <td>39.7</td>
                    <td>6.2</td>
                    <td>52.1</td>
                    <td>30.4</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>1001499999</td>
                    <td>2019-01-02</td>
                    <td>36.4</td>
                    <td>6.2</td>
                    <td>999.9</td>
                    <td>29.8</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>1001499999</td>
                    <td>2019-01-03</td>
                    <td>36.5</td>
                    <td>3.3</td>
                    <td>999.9</td>
                    <td>35.6</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>1001499999</td>
                    <td>UNKNOWN</td>
                    <td>45.6</td>
                    <td>2.2</td>
                    <td>22.0</td>
                    <td>44.8</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>295</th>
                    <td>1001499999</td>
                    <td>2019-12-17</td>
                    <td>40.5</td>
                    <td>6.2</td>
                    <td>999.9</td>
                    <td>39.2</td>
                </tr>
                <tr>
                    <th>296</th>
                    <td>1001499999</td>
                    <td>2019-12-18</td>
                    <td>38.8</td>
                    <td>6.2</td>
                    <td>999.9</td>
                    <td>38.2</td>
                </tr>
                <tr>
                    <th>297</th>
                    <td>1001499999</td>
                    <td>2019-12-19</td>
                    <td>45.5</td>
                    <td>6.1</td>
                    <td>999.9</td>
                    <td>42.7</td>
                </tr>
                <tr>
                    <th>298</th>
                    <td>1001499999</td>
                    <td>2019-12-20</td>
                    <td>51.8</td>
                    <td>6.2</td>
                    <td>35.0</td>
                    <td>41.2</td>
                </tr>
            </tbody>
        </table>
        <p>299 rows × 6 columns</p>

        <p>We notice a few things in the view of a selection of the table. The DATE value UNKNOWN is included (by my
            construction). Also, some GUST values are 999.9 (in the original data). The use of several 9 digits as a
            sentinel is a common convention. The number of 9s used varies, however, as well as does the position of a
            decimal point if any is used. Another common convention is using a -1 as a sentinel for numeric values that
            semantically must be positive for legitimate values. For example, the -1 convention might sensibly be used
            for
            wind gust speed, but it could not be for degrees Fahrenheit or Celsius which can perfectly well have the
            value
            -1 for ordinary Earth surface temperatures. On the other hand, if we were using the same units to measure
            the
            temperatures inside an iron forge (melting point of iron is 2,800℉/1,538℃), -1 would be safely outside the
            possible operating range.</p>

        <p>Looking at the minimum and maximum values of a given variable is often a clue about the sentinels used. For
            numbers—and also for dates—a value that is <em>unreasonably large</em> or <em>unreasonably small</em> is
            generally used for a sentinel. This can go wrong where legitimate measurements later exceed their initially
            anticipated range.</p>


        <pre class="input">pd.DataFrame([sorstokken.min(), sorstokken.max()])
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>STATION</th>
                    <th>DATE</th>
                    <th>TEMP</th>
                    <th>VISIB</th>
                    <th>GUST</th>
                    <th>DEWP</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>1001499999</td>
                    <td>2019-01-01</td>
                    <td>27.2</td>
                    <td>1.2</td>
                    <td>17.1</td>
                    <td>16.5</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>1001499999</td>
                    <td>UNKNOWN</td>
                    <td>88.1</td>
                    <td>999.9</td>
                    <td>999.9</td>
                    <td>63.5</td>
                </tr>
            </tbody>
        </table>

        <p>Here we see that TEMP and DEWP seem always to fall within a "reasonable" range. DATE alerts us to a problem
            value
            this way; it might also do so, but possibly more subtly, if the sentinel had been, e.g. 1900-01-01, which is
            an
            actual date but one from before NOAA measurements were taken. Likewise, VISIB and GUST have unreasonably
            high
            and <em>special</em> looking values. For string values, sentinels are quite likely to occur right in the
            middle
            of valid values. "No Middle Name" is alphabetically between "Naomi" and "Nykko." Let us look more closely at
            these variables with sentinels. Outliers and standard deviation (σ) are discussed more in a later section.
        </p>


        <pre class="input">print(&quot;Normal max:&quot;)
for col in [&#39;VISIB&#39;, &#39;GUST&#39;]:
        s = sorstokken[col]
        print(col, s[s &lt; 999.9].max(), 
              &quot;...standard deviation w/ &amp; w/o sentinel:&quot;,
              f&quot;{s.std():.1f} / {s[s &lt; 999.9].std():.1f}&quot;)
</pre>

        <pre>Normal max:
VISIB 6.8 ...standard deviation w/ &amp; w/o sentinel: 254.4 / 0.7
GUST 62.2 ...standard deviation w/ &amp; w/o sentinel: 452.4 / 8.1
</pre>

        <p>I believe VISIB is measured in miles, and seeing a thousand miles is unreasonable. GUST wind speed is in MPH,
            and
            likewise 999.9 is not something that will occur on Earth. However, one should worry when sentinels are
            within
            three orders of magnitude of actual values, as here. For power law distributed values, even that rule of
            thumb
            about orders of magnitude is of little help.</p>

        <p>In Pandas and other tools, we can instruct the tool to look for specific sentinels, and substitute specific
            values. Of course, we could do so after data is read into a data structure using regular data frame
            filtering
            and manipuation techniques. If we can do so at read time, so much the better. Here we look for sentinels on
            a
            column-specific basis:</p>


        <pre class="input">sorstokken = pd.read_csv(&#39;data/sorstokken-no.csv.gz&#39;, 
                         na_values={&#39;DATE&#39;: &#39;UNKNOWN&#39;, 
                                    &#39;VISIB&#39;: &#39;999.9&#39;,
                                    &#39;GUST&#39;: &#39;999.9&#39;},
                         parse_dates=[&#39;DATE&#39;])
sorstokken.head()
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>STATION</th>
                    <th>DATE</th>
                    <th>TEMP</th>
                    <th>VISIB</th>
                    <th>GUST</th>
                    <th>DEWP</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>1001499999</td>
                    <td>2019-01-01</td>
                    <td>39.7</td>
                    <td>6.2</td>
                    <td>52.1</td>
                    <td>30.4</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>1001499999</td>
                    <td>2019-01-02</td>
                    <td>36.4</td>
                    <td>6.2</td>
                    <td>NaN</td>
                    <td>29.8</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>1001499999</td>
                    <td>2019-01-03</td>
                    <td>36.5</td>
                    <td>3.3</td>
                    <td>NaN</td>
                    <td>35.6</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>1001499999</td>
                    <td>NaT</td>
                    <td>45.6</td>
                    <td>2.2</td>
                    <td>22.0</td>
                    <td>44.8</td>
                </tr>
                <tr>
                    <th>4</th>
                    <td>1001499999</td>
                    <td>2019-01-06</td>
                    <td>42.5</td>
                    <td>1.9</td>
                    <td>NaN</td>
                    <td>42.5</td>
                </tr>
            </tbody>
        </table>

        <p>The topics in this section are largely driven by data formats themselves. Let us turn to anomalies caused
            more
            often by collection processes.</p>

    </div>
    <div class="hidden" id="3">
        <h2>Miscoded Data</h2>

        <blockquote>
            <p>"When I use a word," Humpty Dumpty said, in rather a scornful
                tone, "it means just what I choose it to mean—neither more
                nor less."<br />–Lewis Carroll</p>
        </blockquote>

        <p><strong>Concepts</strong>:</p>
        <ul>
            <li>Categorical and ordinal constraints</li>
            <li>Encoded values and metadata definitions</li>
            <li>Rare categories</li>
        </ul>

        <p>When I discuss miscoded data in this section, I am primarily addressing categorical data, also called
            "factors"
            in R (and sometimes elsewhere). Ordinal data might be included too inasmuch as it has known bounds. For
            example,
            if a ranking scale is specified as ranging from 1 to 10, any values outside of that numeric range—or if
            genuinely ordinal, any values that are not integral—must be miscoded in some manner.</p>

        <p>Quantitative data can obviously be miscoded as well, in some sense. A data entry intending a value of 55
            might be
            carelessly entered as 555. But equally, a value intended as 55 might be mis-entered as 54, which is less
            likely
            to be caught as obviously wrong. In any event, examination of quantitative features for errors is addressed
            in
            the later sections of this chapter. Numbers, especially real numbers (or complex numbers, integers,
            fractions,
            etc.) do not present as immediately wrong, but only in their distribution or domain constraints.</p>

        <p>For an ordinal value, verifying its type and range should assure the validity of the coding, in most cases
            (ordinals with non-contiguous integers as valid values do occur sometimes, but less common). In the <a
                href="https://archive.ics.uci.edu/ml/datasets/Dermatology">Dermatology Data Set</a> available from the
            UCI
            Machine Learning Repository, most fields are coded as 0, 1, 2, or 3. One field is only 0 or 1, the age and
            target (the skin condition) are continuous and factor variables, respectively. In this example, nothing is
            miscoded; note that verifying that is <em>not</em> the same as knowing all values are <em>correct</em>.</p>


        <pre class="input">from src.dermatology import *
(pd.DataFrame(
    [derm.min(), derm.max(), derm.dtypes])
     .T
     .rename(columns={0:&#39;min&#39;, 1:&#39;max&#39;, 2:&#39;dtype&#39;})
)
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>min</th>
                    <th>max</th>
                    <th>dtype</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>erythema</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>scaling</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>definite borders</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>itching</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>inflammatory monoluclear inflitrate</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>band-like infiltrate</th>
                    <td>0</td>
                    <td>3</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>Age</th>
                    <td>0</td>
                    <td>75</td>
                    <td>float64</td>
                </tr>
                <tr>
                    <th>TARGET</th>
                    <td>cronic dermatitis</td>
                    <td>seboreic dermatitis</td>
                    <td>object</td>
                </tr>
            </tbody>
        </table>
        <p>35 rows × 3 columns</p>

        <p>Minimum, maximum and verifying use of integer data type is sufficient to assure ordinals are not miscoded.
            Categorical variables are <em>sometimes</em> encoded in an ordinal fashion, but often consist of words
            naming
            their values. For example, the below data set is very similar to the one used in an exercise of chapter 6.
            However, in this version, some errors exist that we will look at in the next several sections. This data
            contains (hypothetical) height, weight, hair length, and favorite color of 25,000 suvey subjects.</p>


        <pre class="input">humans = pd.read_csv(&#39;data/humans-err.csv&#39;)
# random_state for deterministic sample
humans.sample(5, random_state=1)  
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>21492</th>
                    <td>176.958650</td>
                    <td>72.604585</td>
                    <td>14.0</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>9488</th>
                    <td>169.000221</td>
                    <td>79.559843</td>
                    <td>0.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>16933</th>
                    <td>171.104306</td>
                    <td>71.125528</td>
                    <td>5.5</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>12604</th>
                    <td>174.481084</td>
                    <td>79.496237</td>
                    <td>8.1</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>8222</th>
                    <td>171.275578</td>
                    <td>77.094118</td>
                    <td>14.6</td>
                    <td>green</td>
                </tr>
            </tbody>
        </table>

        <p>As one would expect semantically, <code>Favorite</code> is a categorical value, with a small number of
            legitimate
            values. Generally the way to examine such a feature for miscoding starts with examing the unique values it
            takes. Obviously, if documentation exists as to the expected values that can help us. However, keep in mind
            a
            software developers' motto that "documentation" is a synonym for "<em>lies</em>." It may not accurately
            reflect
            the data itself.</p>


        <pre class="input">humans.Favorite.unique()
</pre>


        <pre>array([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;Red&#39;, &#39; red&#39;, &#39;grееn&#39;, &#39;blüe&#39;,
       &#39;chartreuse&#39;], dtype=object)</pre>

        <p>At an initial look at unique values, we already see several likely problems. For example, <code>' red'</code>
            with a space at the beginning is a common kind of data entry error, and we can most likely assume it was
            intended simply as <code>'red'</code>. On the other hand, <code>'Red'</code> capitalized versus in lower
            case is
            not necessarily self-evident as to which is correct. The string <code>'blüe'</code> looks like another
            misspelling of the English word. Something strange is happening with the <code>'green'</code> still; we will
            return to that.</p>

        <p>To get a sense of the intention of the data, we can check whether some variations are rare with others
            common.
            This is often a strong hint.</p>


        <pre class="input">humans.Favorite.value_counts()
</pre>


        <pre>red           9576
blue          7961
green         7458
grееn            1
 red             1
blüe             1
chartreuse       1
Red              1
Name: Favorite, dtype: int64</pre>

        <p>These counts tell us a lot. The color <code>'chartreuse'</code> is a perfectly good color name, albeit a less
            commonly used word. It <em>could</em> be a legitimate value, but most likely its rarity indicates some sort
            of
            improper entry, given that only three colors (modulo some spelling issues we are working on) seem to be
            otherwise available. Most likely, we will want to mark this value as missing for later processing. But
            <em>only</em> most likely; there may be domain knowledge that indicates that despite its rarity, it is a
            value
            we wish to consider. If documentation exists describing it, that lends weight to the option of simply
            keeping
            it.
        </p>

        <p>The rare occurrence of <code>' red'</code> with a leading space and <code>'Red'</code> capitalized give us
            strong
            support for the assumption that they are simply miscoded version of 'red'. However, if we were roughly
            evenly
            split on capitalized and lowercase versions, or even if neither was <em>rare</em>, the correct action is
            less
            clear. Nonetheless, in many cases, canonicalization or normalization to one particular case (case folding)
            would
            be good practice, and data frame tools make this easy to vectorize on large data sets. However, sometimes
            capitalization represent intended differences, for example in otherwise identical last names that have
            distinct
            capitalization among different families. Likewise, in many scientific fields, short names or formulae can be
            case-sensitive and should not be case-folded. Having a sense of the content domain remains important.</p>

        <p>We are left with the curious case of the two greens. They look identical; likewise, for example a trailing
            space
            in the above categorical values would not be visible on screen. Manually looking closer at those values is
            needed here.</p>


        <pre class="input">for color in sorted(humans.Favorite.unique()):
    print(f&quot;{color:&gt;10s}&quot;, [ord(c) for c in color])
</pre>

        <pre>       red [32, 114, 101, 100]
       Red [82, 101, 100]
      blue [98, 108, 117, 101]
      blüe [98, 108, 252, 101]
chartreuse [99, 104, 97, 114, 116, 114, 101, 117, 115, 101]
     green [103, 114, 101, 101, 110]
     grееn [103, 114, 1077, 1077, 110]
       red [114, 101, 100]
</pre>

        <p>What we find here from the Unicode code points is that one of our greens in fact has two Cyrillic 'ye'
            characters
            rather than Roman 'e's. This substitution of near-identical glyphs is often—as in this instance of a sneaky
            book
            author—a result of malice or deception. However, in the large world of human languages, it genuinely can
            occur
            that a particular string of characters innocently resembles some other string it is not. Other than perhaps
            making it more difficult to type some strings at the particular keyboard with which you are familiar, this
            visual similarity is not per se a data integrity issue. However, here, with the one mixed-language version
            also
            being rare, clearly it is something to correct to the regular English word in Roman letters.</p>

        <p>Once we have made decisions about the remediations desired—in a manner sensitive to domain knowledge—we can
            translate troublesome values. For example:</p>


        <pre class="input">humans.loc[humans.Favorite.isin([&#39;Red&#39;, &#39; red&#39;]), &#39;Favorite&#39;] = &#39;red&#39;
humans.loc[humans.Favorite == &#39;chartreuse&#39;, &#39;Favorite&#39;] = None
humans.loc[humans.Favorite == &#39;blüe&#39;, &#39;Favorite&#39;] = &#39;blue&#39;
humans.loc[humans.Favorite == &#39;grееn&#39;, &#39;Favorite&#39;] = &#39;green&#39;
humans.Favorite.value_counts()
</pre>


        <pre>red      9578
blue     7962
green    7459
Name: Favorite, dtype: int64</pre>

        <p>Let us turn to areas where domain knowledge can inform anomaly detection.</p>

    </div>
    <div class="hidden" id="4">
        <h2>Fixed Bounds</h2>

        <blockquote>
            <p>Cricket is an art. Like all arts it has a technical foundation. To enjoy it
                does not require technical knowledge, but analysis that is not technically
                based is mere impressionism”<br />–C.L.R. James, <em>Beyond A Boundary</em></p>
        </blockquote>

        <p><strong>Concepts</strong>:</p>
        <ul>
            <li>Domain versus measurement limits</li>
            <li>Imputation and clipping</li>
            <li>Improbability versus impossibility</li>
            <li>Exploring hypotheses for data errors</li>
        </ul>

        <p>Based on our domain knowledge of the problem and data set at hand, we may know of fixed bounds for particular
            variables. For example, we might know that the tallest human who has lived was Robert Pershing Wadlow at
            271㎝ ;
            and that the shortest adult was Chandra Bahadur Dangi at 55㎝ . Values outside this range are probably
            unreasonable to allow in our data set. In fact, we may perhaps wish to assume much stricter bounds; as an
            example, let us choose between 92㎝ and 213㎝ (which will include the <em>vast</em> majority of all adult
            humans).
            Let us check whether our humans data set conforms with these bounds.</p>


        <pre class="input">((humans.Height &lt; 92) | (humans.Height &gt; 213)).any()
</pre>


        <pre>False</pre>

        <p>For height, then, our domain specific fixed bounds are not exceeded in the data set. What about the variable
            <code>Hair_Length</code>? From the actual physical meaning of the measurement, hair cannot be negative
            length.
            However, let us stipulate as well that the measuring tape used for our observations was 120㎝ (i.e.
            hypothetical
            domain knowledge), and that, therefore, a length more than that cannot be completely legitimate (such a
            length
            is rare, but not impossible among humans). First, let us look at the hair lengths that exceed the measuring
            instrument.
        </p>


        <pre class="input">humans.query(&#39;Hair_Length &gt; 120&#39;)
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>1984</th>
                    <td>165.634695</td>
                    <td>62.979993</td>
                    <td>127.0</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>8929</th>
                    <td>175.186061</td>
                    <td>73.899992</td>
                    <td>120.6</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>14673</th>
                    <td>174.948037</td>
                    <td>77.644434</td>
                    <td>130.1</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>14735</th>
                    <td>176.385525</td>
                    <td>68.735397</td>
                    <td>121.7</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>16672</th>
                    <td>173.172298</td>
                    <td>71.814699</td>
                    <td>121.4</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>17093</th>
                    <td>169.771111</td>
                    <td>77.958278</td>
                    <td>133.2</td>
                    <td>blue</td>
                </tr>
            </tbody>
        </table>

        <p>There are just a few samples with a hair length longer than a possible measurement. However, all of these
            numbers
            are only modestly longer than the measuring instrument or scale. Without more information on the collection
            procedure, it is not possible to be confident of the source of the error. Perhaps some subjects made their
            own
            estimates of their very long hair length rather than use the instrument. Perhaps one data collection site
            actually had a longer measuring tape that was not documented in our metadata or data description. Or perhaps
            there is a transcription error, such as adding a decimal point; e.g. maybe the 124.1㎝ hair was 24.1㎝ in
            reality.
            Or perhaps the unit was confused, and millimeters were actually measured rather than centimeters (as is
            standard
            in hair clippers and other barbering equipment).</p>

        <p>In any case, this problem affects only 6 of the 25,000 observations. Dropping those rows would not lose a
            large
            amount of data, so that is a possibility. Imputing values would perhaps be reasonable (for example,
            stipulating
            these 6 subjects had average hair length). Value imputation is the subject of chapter 6, and options are
            discussed there in more detail; at this stage, the first pass might be marking those values as missing.</p>

        <p>However, for these out-of-range values that cluster relatively close to legitimate values, clipping the
            values to
            the documented maximum might also be a reasonable approach. The operation "clip" is also sometimes called
            "clamp," "crop," or "trim" depending on the library you are working with. The general idea is simply that a
            value outside of a certain bound is treated as if it is that bound itself. We can version our data as we
            modify
            it.</p>


        <pre class="input">humans2 = humans.copy()  # Retain prior versions of data set
humans2[&#39;Hair_Length&#39;] = humans2.Hair_Length.clip(upper=120)
humans2[humans2.Hair_Length &gt; 119]
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>1984</th>
                    <td>165.634695</td>
                    <td>62.979993</td>
                    <td>120.0</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>4146</th>
                    <td>173.930107</td>
                    <td>72.701456</td>
                    <td>119.6</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>8929</th>
                    <td>175.186061</td>
                    <td>73.899992</td>
                    <td>120.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>9259</th>
                    <td>179.215974</td>
                    <td>82.538890</td>
                    <td>119.4</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>14673</th>
                    <td>174.948037</td>
                    <td>77.644434</td>
                    <td>120.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>14735</th>
                    <td>176.385525</td>
                    <td>68.735397</td>
                    <td>120.0</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>16672</th>
                    <td>173.172298</td>
                    <td>71.814699</td>
                    <td>120.0</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>17093</th>
                    <td>169.771111</td>
                    <td>77.958278</td>
                    <td>120.0</td>
                    <td>blue</td>
                </tr>
            </tbody>
        </table>

        <p>A slightly lower threshold for a filter shows that 119.6 was left unchanged, but the values over 120.0 were
            all
            set to 120 exactly.</p>

        <p>The too big values were not difficult to massage. Let us look at the physical lower bound of zero next. A
            value
            of exactly zero is perfectly reasonable. Many people shave their head or are otherwise bald. This is
            invented
            data, pulled from a distribution that feels vaguely reasonable to this author, so do not put too much weight
            in
            the exact distributions of lengths. Just note that zero length is a relatively common occurrence in actual
            humans.</p>


        <pre class="input">humans2[humans2.Hair_Length == 0]
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>6</th>
                    <td>177.297182</td>
                    <td>81.153493</td>
                    <td>0.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>217</th>
                    <td>171.893967</td>
                    <td>68.553526</td>
                    <td>0.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>240</th>
                    <td>161.862237</td>
                    <td>76.914599</td>
                    <td>0.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>354</th>
                    <td>172.972247</td>
                    <td>73.175032</td>
                    <td>0.0</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>24834</th>
                    <td>170.991301</td>
                    <td>67.652660</td>
                    <td>0.0</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>24892</th>
                    <td>177.002643</td>
                    <td>77.286141</td>
                    <td>0.0</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>24919</th>
                    <td>169.012286</td>
                    <td>74.593809</td>
                    <td>0.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>24967</th>
                    <td>169.061308</td>
                    <td>65.985481</td>
                    <td>0.0</td>
                    <td>green</td>
                </tr>
            </tbody>
        </table>
        <p>517 rows × 4 columns</p>

        <p>However, what about the impossible negative lengths? We can easily create a filter to look at those also.</p>


        <pre class="input">neg_hair = humans2[humans2.Hair_Length &lt; 0]
neg_hair
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>493</th>
                    <td>167.703398</td>
                    <td>72.567763</td>
                    <td>-1.0</td>
                    <td>blue</td>
                </tr>
                <tr>
                    <th>528</th>
                    <td>167.355393</td>
                    <td>60.276190</td>
                    <td>-20.7</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>562</th>
                    <td>172.416114</td>
                    <td>60.867457</td>
                    <td>-68.1</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>569</th>
                    <td>177.644146</td>
                    <td>74.027147</td>
                    <td>-5.9</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>24055</th>
                    <td>172.831608</td>
                    <td>74.096660</td>
                    <td>-13.3</td>
                    <td>red</td>
                </tr>
                <tr>
                    <th>24063</th>
                    <td>172.687488</td>
                    <td>69.466838</td>
                    <td>-14.2</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>24386</th>
                    <td>176.668430</td>
                    <td>62.984811</td>
                    <td>-1.0</td>
                    <td>green</td>
                </tr>
                <tr>
                    <th>24944</th>
                    <td>172.300925</td>
                    <td>72.067862</td>
                    <td>-24.4</td>
                    <td>red</td>
                </tr>
            </tbody>
        </table>
        <p>118 rows × 4 columns</p>

        <p>There are a moderate number of these obviously miscoded rows. As elsewhere, simply dropping the problem rows
            is
            often a reasonable approach. However, a quick glance at the tabular data, as well as some slight forensics,
            suggest that quite likely a negative sign snuck into many reasonable values. It is at least
            <em>plausible</em>
            that these quantities are right, but simply with inverted sign. Let us look at some statstics of the problem
            values. Just for fun, we will look at very similar summaries using both R and Pandas.
        </p>


        <pre class="input">%%R -i neg_hair
summary(neg_hair$Hair_Length)
</pre>

        <pre>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 -95.70  -38.08  -20.65  -24.35   -5.60   -0.70 
</pre>


        <pre class="input">neg_hair.Hair_Length.describe()
</pre>


        <pre>count    118.000000
mean     -24.348305
std       22.484691
min      -95.700000
25%      -38.075000
50%      -20.650000
75%       -5.600000
max       -0.700000
Name: Hair_Length, dtype: float64</pre>

        <p>The general statistics do not contradict this sign-inversion hypothesis. However, before we draw a
            conclusion,
            let us continue to look at these bad values more closely for this exercise. There might be additional
            patterns.
        </p>


        <pre class="input">plt.hist(neg_hair.Hair_Length, bins=30)
plt.title(&quot;Distribution of invalid negative hair length&quot;)
plt.savefig(&quot;img/(Ch04)Distribution of invalid negative hair length.png&quot;)
</pre>

        <img src="data:image/png;base64,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
">

        <p>This distribution of negative values roughly matches the distribution of positive ones. There are a larger
            number
            of people with short hair of varying short lengths, and a tail of fewer people at longer lengths. However,
            at a
            glance, the region close to zero seems to be a bit <em>too much</em> of a peak. For the one hundred or so
            rows
            of data in the example, you could eyeball them all manually, but for larger data sets, or larger
            bounds-violation sets, honing in on nuances programmatically is more general.</p>


        <pre class="input">neg_hair.Hair_Length.value_counts()
</pre>


        <pre>-1.0     19
-41.6     2
-6.8      2
-30.1     2
         ..
-3.3      1
-51.4     1
-25.1     1
-4.8      1
Name: Hair_Length, Length: 93, dtype: int64</pre>

        <p>Indeed there is a pattern here. There are 19 values of <em>exactly</em> -1, and only 1 or two occurrences of
            each
            other invalid negative value. It seems very likely that something different is happening between the -1
            error
            and the other negative value errors. Perhaps -1 was used as a sentinel, for example. Of course, it is also
            possible that -1 could result from the stipulated sign-inversion error; we cannot entirely separate those
            two
            possibilities.</p>

        <p>The working hypothesis I would probably use to handle this problem in the data set (if not simply drop
            everything
            questionable outright) would be to mark the -1 values as <em>missing</em> but invert the sign of other
            negative
            values.</p>


        <pre class="input">humans3 = humans2.copy()     # Versioned changes to data

# The &quot;sentinel&quot; negative value means missing
humans3.loc[humans3.Hair_Length == -1, &#39;Hair_Length&#39;] = None

# All other values simply become non-negative
humans3[&#39;Hair_Length&#39;] = humans3.Hair_Length.abs()

plt.hist(humans3.Hair_Length, bins=30)
plt.title(&quot;Distribution of corrected hair lengths&quot;)
plt.savefig(&quot;img/(Ch04)Distribution of corrected hair lengths.png&quot;)
</pre>

        <img src="data:image/png;base64,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
">

        <p>We have performed a typical cleaning of bounded values. Let us turn to values without sharp bounds, but with
            general distribution statistics.</p>

    </div>
    <div class="hidden" id="5">
        <h2>Outliers</h2>

        <blockquote>
            <p>If Congress had meant to so limit the Act, it surely would have used words
                to that effect.<br />–Tennessee Valley Auth. v. Hill, 437 U.S. 153 (1978)</p>
        </blockquote>

        <p><strong>Concepts</strong>:</p>
        <ul>
            <li>Z-score and unexpected values</li>
            <li>Interquartile range</li>
            <li>Standard deviation and frequency of occurrence</li>
        </ul>

        <p>In continuous data, values that fall within normative ranges might still be strongly uncharacteristic within
            those bounded expectations. In the simplest case, this occurs when a value is very different from other
            values
            of the same variable. The standard way to characterize the expectedness of a value is a measure called
            z-score.
            This value is simply the distance of each point from the mean of the variable, divided by the standard
            deviation
            of the variable.</p>
        $$Z = \frac{x - \mu}{\sigma}$$<p>Where $\mu$ is sample mean, and $\sigma$ is standard deviation.</p>

        <p>This measure is most precise for data that follows a normal distribution, but generally it is useful for any
            data
            that is unimodal (having one peak), somewhat symmetric, and scale dependent. In more ordinary language, we
            just
            want to look for the histogram of a data variable having one peak, and tapering off at roughly the same rate
            on
            both sides. Completely normal distribution is unusual in real-world data.</p>

        <p>A slightly different way of identifying outliers is often used as well. Box and whisker plots (usually simply
            called boxplots) will often include outliers as separate visual elements. While it is possible to use
            z-score in
            such a visualization, more often these plots utilize interquartile range (IQR) and a fixed multiplier to
            define
            outliers. The different techniques will produce similar, but not identical, answers.</p>

    </div>
    <div class="hidden" id="5-1">
        <h3>Z-Score</h3>

        <p>We can see that height and weight in our data set follow a generally normal-like distribution by visualizing
            them. We have seen just above that hair length, after correction, is strictly single tailed. However, the
            one-sided drop-off from a mode at 0 is close enough to one tail of a normal distribution, that z-score is
            still
            reasonable to consider.</p>


        <pre class="input">fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
ax1.hist(humans3.Height, bins=50)
ax2.hist(humans3.Weight, bins=50)
ax1.set_title(&quot;Distribution of Height&quot;)
ax2.set_title(&quot;Distribution of Weight&quot;)
fig.savefig(&quot;img/(Ch04)Distribution of Height and Weight.png&quot;)
</pre>

        <img src="data:image/png;base64,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
">

        <p>If we wish to be more precise in quantifying normality of variables, we can use statistical tests such and
            Anderson-Darling, Shapiro–Wilk, or Skewness-Kurtosis All. Each of these techniques tries to reject the
            hypothesis that a distribution is normal. For different p-values (probabilities), different test statistics
            determine a threshold for this rejection (although for large samples, even small deviations from normality
            will
            reject the hypothesis, but not matter from the point of view of z-score being useful). In Anderson-Darling,
            if
            the test statistic is not much more than 1.0 the curve is definitely <em>normal enough</em> to measure
            outliers
            with z-score. The inverse does not hold, however; many non-normal curves are still reasonable to use z-score
            with. Essentially, we just need to avoid this measure for power law or exponential distributions, and for
            curves
            that are strongly multi-modal. Let us perform Anderson-Darling tests on our height, weight, and hair length
            variables.Let us perform Anderson-Darling tests on our height, weight, and hair length variables.</p>


        <pre class="input">from scipy.stats import anderson

for var in (&#39;Height&#39;, &#39;Weight&#39;, &#39;Hair_Length&#39;):
    data = humans3[var][humans3[var].notnull()]
    stat = anderson(data, &#39;norm&#39;).statistic
    print(f&quot;Anderson-Darling statistic for {var:&lt;12s}: {stat:6.2f}&quot;)
</pre>

        <pre>Anderson-Darling statistic for Height      :   0.24
Anderson-Darling statistic for Weight      :   0.54
Anderson-Darling statistic for Hair_Length : 578.19
</pre>

        <p>Having recognized that hair length is not normal, but that it shows a one-sided decay along a linear scale
            nonetheless, we can add z-scores for all of our quantitative variables to the working data frame. As before,
            as
            good practice of keeping versions of our modifications, we copy the data to a new data frame before the next
            transformations. We ignore the delta degrees of freedom parameter in our calculation of standard deviation
            because it is trivial with 25 thousand samples (if we had only 10 or 20 samples, it could matter). The
            degrees
            of freedom concerns the anticipated variance within a total population based on a sample; but these only
            vary
            significantly when samples are tens of observations, not tens of thousands.The degrees of freedom concerns
            the
            anticipated variance within a total population based on a sample; but these only vary significantly when
            samples
            are tens of observations, not tens of thousands.</p>


        <pre class="input">humans4 = humans3.copy()

for var in (&#39;Height&#39;, &#39;Weight&#39;, &#39;Hair_Length&#39;):
    zscore = (humans4[var] - humans4[var].mean()) / humans4[var].std()
    humans4[f&quot;zscore_{var}&quot;] = zscore
    
humans4.sample(5, random_state=1)
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                    <th>zscore_Height</th>
                    <th>zscore_Weight</th>
                    <th>zscore_Hair_Length</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>21492</th>
                    <td>176.958650</td>
                    <td>72.604585</td>
                    <td>14.0</td>
                    <td>red</td>
                    <td>0.880831</td>
                    <td>-0.042032</td>
                    <td>-0.568786</td>
                </tr>
                <tr>
                    <th>9488</th>
                    <td>169.000221</td>
                    <td>79.559843</td>
                    <td>0.0</td>
                    <td>blue</td>
                    <td>-0.766210</td>
                    <td>0.997585</td>
                    <td>-1.225152</td>
                </tr>
                <tr>
                    <th>16933</th>
                    <td>171.104306</td>
                    <td>71.125528</td>
                    <td>5.5</td>
                    <td>red</td>
                    <td>-0.330758</td>
                    <td>-0.263109</td>
                    <td>-0.967294</td>
                </tr>
                <tr>
                    <th>12604</th>
                    <td>174.481084</td>
                    <td>79.496237</td>
                    <td>8.1</td>
                    <td>blue</td>
                    <td>0.368085</td>
                    <td>0.988078</td>
                    <td>-0.845397</td>
                </tr>
                <tr>
                    <th>8222</th>
                    <td>171.275578</td>
                    <td>77.094118</td>
                    <td>14.6</td>
                    <td>green</td>
                    <td>-0.295312</td>
                    <td>0.629028</td>
                    <td>-0.540656</td>
                </tr>
            </tbody>
        </table>

        <p>The choice of a z-score threshold is very domain and problem dependent. A rule of thumb is often to use a
            z-score
            of absolute value more than 3 as a cut-off to define outliers. But what is <em>expected</em> very much
            depends
            on the size of a data set. In statistics, we sometimes recall the "68–95–99.7 Rule" which lists the
            percentage
            of observations that fall within one, two, or three standard deviations in a normal distribution. At any
            distance from the mean, <em>some</em> observations would be expected if they are numerous enough, but the
            number
            diminishes rapidly with more standard deviations distance.</p>

        <p>Let us look at that common z-score threshold of 3. Remember that we are working with 25,000 samples here, so
            generally we expect to find roughly 75 of them outside of 3 standard deviations, under the "68–95–99.7 rule"
            discussed below. Let us look at the table for height, but just check the number of rows outside this bound
            for
            the other variables.</p>


        <pre class="input">humans4[humans4.zscore_Height.abs() &gt; 3]
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                    <th>zscore_Height</th>
                    <th>zscore_Weight</th>
                    <th>zscore_Hair_Length</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>138</th>
                    <td>187.708718</td>
                    <td>86.829633</td>
                    <td>19.3</td>
                    <td>green</td>
                    <td>3.105616</td>
                    <td>2.084216</td>
                    <td>-0.320304</td>
                </tr>
                <tr>
                    <th>174</th>
                    <td>187.537446</td>
                    <td>79.893761</td>
                    <td>37.5</td>
                    <td>blue</td>
                    <td>3.070170</td>
                    <td>1.047496</td>
                    <td>0.532971</td>
                </tr>
                <tr>
                    <th>412</th>
                    <td>157.522316</td>
                    <td>62.564977</td>
                    <td>6.8</td>
                    <td>blue</td>
                    <td>-3.141625</td>
                    <td>-1.542673</td>
                    <td>-0.906345</td>
                </tr>
                <tr>
                    <th>1162</th>
                    <td>188.592435</td>
                    <td>86.155948</td>
                    <td>53.1</td>
                    <td>red</td>
                    <td>3.288506</td>
                    <td>1.983518</td>
                    <td>1.264351</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>22945</th>
                    <td>157.293031</td>
                    <td>44.744929</td>
                    <td>18.4</td>
                    <td>red</td>
                    <td>-3.189077</td>
                    <td>-4.206272</td>
                    <td>-0.362499</td>
                </tr>
                <tr>
                    <th>23039</th>
                    <td>187.845548</td>
                    <td>88.554510</td>
                    <td>6.9</td>
                    <td>blue</td>
                    <td>3.133934</td>
                    <td>2.342037</td>
                    <td>-0.901657</td>
                </tr>
                <tr>
                    <th>24244</th>
                    <td>158.153049</td>
                    <td>59.725932</td>
                    <td>13.8</td>
                    <td>green</td>
                    <td>-3.011091</td>
                    <td>-1.967031</td>
                    <td>-0.578162</td>
                </tr>
                <tr>
                    <th>24801</th>
                    <td>189.310696</td>
                    <td>85.406727</td>
                    <td>2.3</td>
                    <td>green</td>
                    <td>3.437154</td>
                    <td>1.871531</td>
                    <td>-1.117320</td>
                </tr>
            </tbody>
        </table>
        <p>51 rows × 7 columns</p>


        <pre class="input">print(&quot;Outlier weight:&quot;, (humans4.zscore_Weight.abs() &gt; 3).sum())
print(&quot;Outlier hair length:&quot;, (humans4.zscore_Hair_Length.abs() &gt; 3).sum())
</pre>

        <pre>Outlier weight: 67
Outlier hair length: 285
</pre>

        <p>We have already noted that hair length is single tailed, so we might expect approximately twice as many
            outliers.
            The actual number is somewhat more than twice that many, but that is not itself an extreme divergence of
            values.
            Height and weight actually have modestly lower kurtosis than we would expect from the normal distribution
            (the
            tails thin out slightly faster). In any case, a z-score of 3 is probably too small to be useful for our
            sample
            size. 4 sigma is probably more relevant for our purpose of distinguishing merely unusual from probably-wrong
            observations, and maybe 4.5 for the one-tailed hair length.</p>

        <p>A table of the frequency of once-a-day observations falling outside of a given standard deviation (σ)
            provides a
            helpful intuition. A shorthand trick to remember the effect of sigma is the so-called <em>68–95–99.7
                rule</em>;
            that is, the percentage of things falling within one, two, and three standard deviations.</p>

        <table>
            <thead>
                <tr>
                    <th>Range</th>
                    <th>Proportion of observations</th>
                    <th style="text-align:left">Frequency for daily event </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>± 1σ</td>
                    <td>1 in 3</td>
                    <td style="text-align:left">Twice a week</td>
                </tr>
                <tr>
                    <td>± 2σ</td>
                    <td>1 in 22</td>
                    <td style="text-align:left">Every three weeks </td>
                </tr>
                <tr>
                    <td>± 3σ</td>
                    <td>1 in 370</td>
                    <td style="text-align:left">Yearly</td>
                </tr>
                <tr>
                    <td>± 4σ</td>
                    <td>1 in 15,787</td>
                    <td style="text-align:left">43 years (twice in a lifetime)</td>
                </tr>
                <tr>
                    <td>± 5σ</td>
                    <td>1 in 1,744,278</td>
                    <td style="text-align:left">5000 years (once in recorded history)</td>
                </tr>
                <tr>
                    <td>± 6σ</td>
                    <td>1 in 506,797,346</td>
                    <td style="text-align:left">1.4 million years (twice in history of humankind)</td>
                </tr>
                <tr>
                    <td>± 7σ</td>
                    <td>1 in 390,682,215,445</td>
                    <td style="text-align:left">1 billion years (four times in history of Earth) </td>
                </tr>
            </tbody>
        </table>

        <p>Let us see the outliers given the broader z-score bounds.</p>


        <pre class="input">cond = (
    (humans4.zscore_Height.abs() &gt; 4) |
    (humans4.zscore_Weight.abs() &gt; 4) |
    (humans4.zscore_Hair_Length.abs() &gt; 4.5))
humans4[cond] 
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                    <th>zscore_Height</th>
                    <th>zscore_Weight</th>
                    <th>zscore_Hair_Length</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>13971</th>
                    <td>153.107034</td>
                    <td>63.155154</td>
                    <td>4.4</td>
                    <td>green</td>
                    <td>-4.055392</td>
                    <td>-1.454458</td>
                    <td>-1.018865</td>
                </tr>
                <tr>
                    <th>14106</th>
                    <td>157.244415</td>
                    <td>45.062151</td>
                    <td>70.7</td>
                    <td>red</td>
                    <td>-3.199138</td>
                    <td>-4.158856</td>
                    <td>2.089496</td>
                </tr>
                <tr>
                    <th>22945</th>
                    <td>157.293031</td>
                    <td>44.744929</td>
                    <td>18.4</td>
                    <td>red</td>
                    <td>-3.189077</td>
                    <td>-4.206272</td>
                    <td>-0.362499</td>
                </tr>
            </tbody>
        </table>

        <p>Using modest domain knowledge of human physical characteristics, even though they are outside the "norm,"
            persons
            of 153㎝ or 45kg are small, but not outside of bounds we would expect. The small number of 4 sigma outliers
            are
            both short and light according to the data, which we would expect to be correlated to a relatively high
            degree,
            lending plausibility to the measurements. Moreover, the height bounds we discussed in the above section on
            fixed
            bounds were considerably wider than this 4 sigma (or even 5 sigma) detects. Therefore, while we
            <em>could</em>
            discard or mark missing values in these outliers rows, the analysis does not seem to motivate doing so.
        </p>

    </div>
    <div class="hidden" id="5-2">
        <h3>Interquartile Range</h3>

        <p>Using interquartile range (IQR) rather than z-score makes less of an assumption of normality of a
            distribution.
            However, this technique will also fails to produce meaningful answers for power law or exponential data
            distributions. If you can identify a distribution as one that ranges over many orders of magnitude like
            those,
            looking at the quartiles of either an Nth root or a logarithm of the raw data might still produce reasonable
            results. The same transformation, in fact, can be equally relevant if you use z-score analysis.</p>

        <p>The idea of IQR is simply to look at the quartile cut-offs in a variable, and measure the numeric distance
            between the first and third quartile, i.e. between the 25% and 75% percentiles. Exactly half the data is in
            that
            range, but we often also expect that most data will be within some distance beyond those cut-offs, defined
            as a
            multiplier of the range between cut-offs. Most commonly, a multiplier of 1.5 is chosen; this is merely a
            convention that is often useful but lacks any deeper meaning.</p>

        <p>I include in this text a brief function to visualize boxplots that show the IQR defined outliers. Normally,
            this
            functionality is only included in the source code repository for the book, but here I think it is worthwhile
            for
            readers to see the configuration that goes into these few lines in <strong>Matplotlib</strong> (other
            visualization libraries have similar capabilities; often higher-level abstractions with more visual pizzazz,
            in
            fact).</p>


        <pre class="input"># Function defined but not run in this cell
def show_boxplots(df, cols, whis=1.5):
    # Create as many horizontal plots as we have columns
    fig, axes = plt.subplots(len(cols), 1, figsize=(10, 2*len(cols)))
    # For each one, plot the non-null data inside it
    for n, col in enumerate(cols):
        data = df[col][df[col].notnull()]
        axes[n].set_title(f&#39;{col} Distribution&#39;)
        # Extend whiskers to specified IQR multiplier
        axes[n].boxplot(data, whis=whis, vert=False, sym=&#39;x&#39;)
        axes[n].set_yticks([])
    # Fix spacing of subplots at the end
    fig.tight_layout()
    plt.savefig(f&quot;img/boxplot-{&#39;_&#39;.join(cols)}.png&quot;)
</pre>

        <p>While the default multiplier (the "whisker" width) is 1.5, we have already seen that the human data is large
            enough that values have to be relatively extreme to appear as genuinely <em>unlikely</em> to be genuine. We
            choose, therefore, a whisker width of 2.5 instead.</p>


        <pre class="input">show_boxplots(humans4, [&quot;Height&quot;, &quot;Weight&quot;, &quot;Hair_Length&quot;], 2.5)
</pre>

        <img src="data:image/png;base64,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ojtfDlKzaxkQBgAAAAbdoohrc1TWmRyNPBPtq6exPgAAAMw1u0dcM5PJ9mhF+6qrrmotXrx4Gk8DAAAAzTY8PNzaY489Wt327p72dbYz0ZZsAwAAwG8ZIA0AAAB6TLINAAAAkm0AAABoNpVtAAAAkGwDAABAs6lsAwAAgGQbAAAAmk1lGwAAACTbAAAA0Gwq2wAAACDZBgAAgGZT2QYAAADJNgAAADSbyjYAAABItgEAAKDZVLYBAABAsg0AAADNprINAAAAkm0AAABoNpVtAAAAkGwDAABAs6lsAwAAgGQbAAAAmk1lGwAAACTbAAAA0Gwq2wAAANBjkm0AAACQbAMAAECzqWwDAACAZBsAAACaTWUbAAAAJNsAAADQbCrbAAAAINkGAACAZlPZBgAAAMk2AAAANJvKNgAAAEi2AQAAoNlUtgEAAECyDQAAAM2msg0AAACSbQAAAGg2lW0AAACQbAMAAECzqWwDAACAZBsAAACaTWUbAAAAJNsAAADQbCrbAAAAINkGAACAZlPZBgAAAMk2AAAANJvKNgAAAEi2AQAAoNkW9HsD6I/LLrustX79eru/hzZu3Nhat25da+nSpa2FCxfatwNs0aJFrWXLlvV7MwAAaDDJ9jxNtPfee+9+bwbMaZdeeqmEGwCAMUm256Gqor1q1arW8uXL+7w1g2PNmjWtFStW2K/z5DjrGQIAwHgk2/NYJtr77bdfvzdj4NivAACA0cgBAACgx+ZNsr1hw4bW6tWrR6cAAADyDWbSvEm2165d29p///1HpwAAAPINZpJztgEAAKZo5cqVrVNPPbW18847323+t771rdHetUuWLGkdccQRrW233ba1efPm1gc+8IHRy8Wed955o8vm7aGhodbNN9/cuu2221qvfvWrR+fn8ueff/7oOldeeWXrrrvuGr3U7CmnnNL62te+1jrkkENaJ5544pbXO+OMM0af50EPetDoOtXjufz73ve+1sjIyOh2fOMb32hddNFFo8XIxz3ucaPbk+vk7dzmfDzX32WXXUYj18vnze284oorRrdl991337ItX//611tPeMITRrchHXjggaPbntuY8/L5Dj744NFtyedJ+Zzt62633Xaj8++8886BaI+SbQAAgCnKpPKWW24ZjbpMWjORTPe85z1HlzvppJNae+2112iSWiWqKRPYutNOO6117LHH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
">

        <p>The central boxes represent the IQR, from 25% to 75% percentile. The whiskers extend to multiplier times IQR
            above/below the box. An x marks outliers past the whiskers.The central boxes represent the IQR, from 25% to
            75%
            percentile. The whiskers extend to multiplier times IQR above/below the box. An x marks outliers past the
            whiskers.</p>

        <p>Only one outlier appears at this threshold for height, at the short end. Likewise, only two appear for
            weight,
            both at the light end. This was the same pattern we found with z-score. Rather more "outlier" long hair
            length
            occurs, but we already had used a larger z-score to filter that more restrictively. We could similarly use a
            larger <em>whisker</em> width to filter more hair lengths out, if we wished.</p>

        <p>While the visualization is handy, we want to find the actual data rows that are marked with x's in the plots.
            Let
            us code that. We find the quartiles, compute the IQR, then display the inlier ranges.</p>


        <pre class="input">quartiles = (
    humans4[[&#39;Height&#39;, &#39;Weight&#39;]]
    .quantile(q=[0.25, 0.50, 0.75, 1.0]))
quartiles
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0.25</th>
                    <td>169.428884</td>
                    <td>68.428823</td>
                </tr>
                <tr>
                    <th>0.50</th>
                    <td>172.709078</td>
                    <td>72.930616</td>
                </tr>
                <tr>
                    <th>0.75</th>
                    <td>175.953541</td>
                    <td>77.367039</td>
                </tr>
                <tr>
                    <th>1.00</th>
                    <td>190.888112</td>
                    <td>98.032504</td>
                </tr>
            </tbody>
        </table>


        <pre class="input">IQR = quartiles.loc[0.75] - quartiles.loc[0.25]
IQR
</pre>


        <pre>Height    6.524657
Weight    8.938216
dtype: float64</pre>


        <pre class="input">for col, length in IQR.iteritems():
    high = quartiles.loc[0.75, col] + 2.5*IQR[col]
    low = quartiles.loc[0.25, col] - 2.5*IQR[col]
    print(f&quot;Inliers for {col}: [{low:.3f}, {high:.3f}]&quot;)
</pre>

        <pre>Inliers for Height: [153.117, 192.265]
Inliers for Weight: [46.083, 99.713]
</pre>

        <p>Actually filtering using the inlier range in this case gives us the same answer as the z-score approach. Of
            necessity, the very shortest person is the shortest regardless of which outlier detection technique we use.
            But
            selecting a domain motivated IQR multiplier may identify more or fewer outliers than using a domain
            motivated
            z-score, depending on actual data distributions.</p>


        <pre class="input">cond = (
    (humans4.Height &gt; 192.265) |
    (humans4.Height &lt; 153.117) |
    (humans4.Weight &gt; 99.713)  |
    (humans4.Weight &lt; 46.083))
humans4[cond] 
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>Hair_Length</th>
                    <th>Favorite</th>
                    <th>zscore_Height</th>
                    <th>zscore_Weight</th>
                    <th>zscore_Hair_Length</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>13971</th>
                    <td>153.107034</td>
                    <td>63.155154</td>
                    <td>4.4</td>
                    <td>green</td>
                    <td>-4.055392</td>
                    <td>-1.454458</td>
                    <td>-1.018865</td>
                </tr>
                <tr>
                    <th>14106</th>
                    <td>157.244415</td>
                    <td>45.062151</td>
                    <td>70.7</td>
                    <td>red</td>
                    <td>-3.199138</td>
                    <td>-4.158856</td>
                    <td>2.089496</td>
                </tr>
                <tr>
                    <th>22945</th>
                    <td>157.293031</td>
                    <td>44.744929</td>
                    <td>18.4</td>
                    <td>red</td>
                    <td>-3.189077</td>
                    <td>-4.206272</td>
                    <td>-0.362499</td>
                </tr>
            </tbody>
        </table>

        <p>Univariate outliers can be important to detect, but sometimes it is a combination of features that becomes
            anomalous.</p>

    </div>
    <div class="hidden" id="6">
        <h2>Multivariate Outliers</h2>

        <blockquote>
            <p>If you are not part of the solution, you are part of the precipitate.<br />–Anonymous</p>
        </blockquote>

        <p><strong>Concepts</strong>:</p>
        <ul>
            <li>Variance in deterministic synthetic features</li>
            <li>Expectations of relative rarity</li>
        </ul>

        <p>Sometimes univariate features can fall within relatively moderate z-score boundaries, and yet combinations of
            those features are unlikely or unreasonable. Perhaps an actual machine learning model might predict that
            combinations of features are likely to be wrong. In this section we only look at simpler combinations of
            features to identify problematic samples.</p>

        <p>In chapter 7 (<em>Feature Engineering</em>) we discuss polynomial features. That technique multiplies
            together
            the values of two or more variables pertaining to the same observation, and treats that as a new feature.
            For
            example, perhaps neither height nor weight in our working example are outside a reasonable bound, and yet
            the
            multiplicative product of them is. While this is definitely possible, we generally expect these features to
            be
            positively correlated to start with, so multiplication would probably only produce something new
            <em>slightly</em> outside the bounds already detected by univariate outlier detection.
        </p>

        <p>However, let us consider a derived feature that is well-motivated by the specific domain. Body mass index
            (BMI)
            is a measure often used to measure healthy weights for people, and is defined as:</p>
        $$BMI = \frac{kg}{m^2}$$<p>That is, weight and height are in an inverse relationship in this derived quantity
            rather
            than multiplicatively combined. Perhaps this multivariate derived features shows some problem outliers. Let
            us
            construct another data frame version that discards previous calculated columns, but adds BMI and its
            z-score.
        </p>


        <pre class="input">humans5 = humans4[[&#39;Height&#39;, &#39;Weight&#39;]].copy()
# Convert weight from cm to m
humans5[&#39;BMI&#39;] = humans5.Weight / (humans5.Height/100)**2
humans5[&quot;zscore_BMI&quot;] = (
    (humans5.BMI - humans5.BMI.mean()) / 
     humans5.BMI.std()
)
humans5
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>BMI</th>
                    <th>zscore_BMI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>167.089607</td>
                    <td>64.806216</td>
                    <td>23.212279</td>
                    <td>-0.620410</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>181.648633</td>
                    <td>78.281527</td>
                    <td>23.724388</td>
                    <td>-0.359761</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>176.272800</td>
                    <td>87.767722</td>
                    <td>28.246473</td>
                    <td>1.941852</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>173.270164</td>
                    <td>81.635672</td>
                    <td>27.191452</td>
                    <td>1.404877</td>
                </tr>
                <tr>
                    <th>...</th>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <th>24996</th>
                    <td>163.952580</td>
                    <td>68.936137</td>
                    <td>25.645456</td>
                    <td>0.618008</td>
                </tr>
                <tr>
                    <th>24997</th>
                    <td>164.334317</td>
                    <td>67.830516</td>
                    <td>25.117048</td>
                    <td>0.349063</td>
                </tr>
                <tr>
                    <th>24998</th>
                    <td>171.524117</td>
                    <td>75.861686</td>
                    <td>25.785295</td>
                    <td>0.689182</td>
                </tr>
                <tr>
                    <th>24999</th>
                    <td>174.949129</td>
                    <td>71.620899</td>
                    <td>23.400018</td>
                    <td>-0.524856</td>
                </tr>
            </tbody>
        </table>
        <p>25000 rows × 4 columns</p>

        <p>Looking for outliers in the derived feature, we see strong signals. As was discussed, at a z-score of 4 and a
            data set of 25,000 records, we expect to see slightly more than one record appearing as an outlier by
            natural
            random distribution. Indeed, the two z-scores we see below that are only slightly more than 4 in absolute
            value
            occurred in the data set before it was engineered to highlight the lesson of this section.</p>


        <pre class="input">humans5[humans5.zscore_BMI.abs() &gt; 4]
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Height</th>
                    <th>Weight</th>
                    <th>BMI</th>
                    <th>zscore_BMI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>21388</th>
                    <td>165.912597</td>
                    <td>90.579409</td>
                    <td>32.905672</td>
                    <td>4.313253</td>
                </tr>
                <tr>
                    <th>23456</th>
                    <td>187.110000</td>
                    <td>52.920000</td>
                    <td>15.115616</td>
                    <td>-4.741383</td>
                </tr>
                <tr>
                    <th>23457</th>
                    <td>158.330000</td>
                    <td>92.780000</td>
                    <td>37.010755</td>
                    <td>6.402625</td>
                </tr>
                <tr>
                    <th>24610</th>
                    <td>169.082822</td>
                    <td>47.250297</td>
                    <td>16.527439</td>
                    <td>-4.022805</td>
                </tr>
            </tbody>
        </table>

        <p>As well as one example of a moderate outlier for high BMI and one for low BMI, we also have two more extreme
            values on each side. In this case, these were constructed for the section, but similar multivariate outliers
            will occur in the wild. The -4.74 z-score is not an extreme we would expect in 25,000 samples, but is
            perhaps
            not completely implausible. However, the +6.4 z-score is astonomically unlikely to occur without a data
            error
            (or a construction by a book author). Since BMI is a derived feature that combines height and weight—and
            moreover since each of those is within reasonable bounds on its own—the correct approach is almost surely
            simply
            to discard these problem rows. Nothing in the data themselves guide us towards knowing whether weight or
            height
            is the problem value, and no remediation is sensible.</p>

        <p>Fortunately for this particular data set, only 2 (or <em>maybe</em> 4) samples display the problem under
            discussion. We have plentiful data here, and no real harm is done by discarding those rows. Obviously, the
            particular decisions made about z-score thresholds and disposition of particular data rows that are
            illustrated
            in this section and the last several are only examples. You will need to decide within your problem and
            domain
            what are most relevant levels and tests, and what remediations to perform.</p>

    </div>
    <div class="hidden" id="7">
        <h2>Exercises</h2>

        <p>The two exercises in this chapter ask you to look for anomalies first in quantitative data, then in
            categorical
            data.</p>

    </div>
    <div class="hidden" id="7-1">
        <h3>A Famous Experiment</h3>

        <p>The Michelson–Morley experiment was an attempt in the late 19th century to detect the existence of the
            <em>luminiferous aether</em>, a widely assumed medium that would carry light waves. This was the most famous
            "failed experiment" in the history of physics in that it did not detect what it was looking for—something we
            now
            know not to exist at all. The general idea was to measure the speed of light under different orientations of
            the
            equipment relative to the direction of movement of the earth, since relative movement of the ether medium
            would
            add or subtract from the speed of the wave. Yes, it does not work that way under the theory of relativity,
            but
            it was a reasonable guess 150 years ago.
        </p>

        <p>Apart from the physics questions, the data set derived by the Michelson-Morley experiment is widely
            available,
            including as a sample built into R. The same data is available at:</p>
        <blockquote>
            <p><a href="https://www.gnosis.cx/cleaning/morley.dat">https://www.gnosis.cx/cleaning/morley.dat</a></p>
        </blockquote>
        <p>Figuring out the format, which is not complex, is a good first step of this exercise (and typical of real
            data
            science work).</p>

        <p>The specific numbers in this data are measurements of the speed of light in km/s with a zero point of
            299,000.
            So, for example, the mean measurement in experiment 1 was 299,909 km/s. Let us look at the data in the R
            bundle.
        </p>


        <pre class="input">%%R -o morley
data(morley)
morley %&gt;%
    group_by(`Expt`) %&gt;%
    summarize(Mean = mean(Speed), Count = max(Run))
</pre>

        <pre>`summarise()` ungrouping output (override with `.groups` argument)
# A tibble: 5 x 3
   Expt  Mean Count
  &lt;int&gt; &lt;dbl&gt; &lt;int&gt;
1     1  909     20
2     2  856     20
3     3  845     20
4     4  820.    20
5     5  832.    20
</pre>

        <p>In the summary, we just look at the number of runs of each experimental setup, and the mean across that
            setup.
            The raw data has 20 measurements within each setup.</p>

        <p>Using whatever programming language and tools you prefer, identify the outliers first within each setup
            (defined
            by an <code>Expt</code> number) and then within the data collection as a whole. The hope in the original
            experiment was that each setup would show a significant difference in central tendency, and indeed their
            means
            are somewhat different. This book and chapter does not explore confidence levels and null hypotheses in any
            detail, but create a visualization that aids you in gaining visual insight into how much apparent difference
            exists between the several setups.</p>

        <p>If you discard the outliers within each setup, are the differences between setups increased or decreased?
            Answer
            with either a visualization or by looking at statistics on the reduced groups.</p>

    </div>
    <div class="hidden" id="7-2">
        <h3>Misspelled Words</h3>

        <p>For this exercise we return to the 25,000 human measurements we have used to illustrate a number of concepts.
            However, in this variation of the data set, each row has a person's first name (pulled from the US Social
            Security Agency list of common first names over the last century; apologies that the names lean Anglocentric
            because of the past history of US population and immigration trends).</p>

        <p>The data set for this exercise can be found at:</p>
        <blockquote>
            <p><a
                    href="https://www.gnosis.cx/cleaning/humans-names.csv">https://www.gnosis.cx/cleaning/humans-names.csv</a>
            </p>
        </blockquote>

        <p>Unfortunately, our hypothetical data collectors for this data set are simply terrible typists, and they make
            typos when entering names with alarming frequency. There are some number of intended names in this data set,
            but
            quite a few simple miscodings of those names as well. The problem is: how do we tell a real name from a
            typo?
        </p>

        <p>There are a number of ways to measure the similarity of strings, and that provide a clue as to likely typos.
            One
            general class of approach is in terms of <em>edit distance</em> between strings. The R package
            <strong>stringdist</strong>, for example provides Damerau-Levenshtein, Hamming, Levenshtein, and optimal
            sting
            alignment, as measures of edit distance. Less edit-specific fuzzy matching techniques utilize a "bag of
            n-grams"
            approach, and include q-gram, cosine distance, and Jaccard distance. Some heuristic metrics like Jaro and
            Jaro-Winkler are also included in <code>stringdist</code> along with the other measures mentioned. Soundex,
            soundex variants, and metaphone look for similarity of the sounds of words as pronounced, but are therefore
            specific to language and even regional dialect.
        </p>

        <p>In a reversal of the more common pattern of Python versus R libraries, Python is the one that scatters string
            similarity measures over numerous libraries, each including just a few measures. However,
            <strong>python-Levenshtein</strong> is a very nice package including most of these measures. If you want
            cosine
            similarity, you may have to use <code>sklearn.metrics.pairwise</code> or another module. For phonetic
            comparisons, <strong>fonetika</strong> and <strong>soundex</strong> both support multiple languages (but
            different languages for each; English is in common for almost all packages).
        </p>

        <p>On my personal system, I have a command-line utility called <code>similarity</code> that I use to measure how
            close strings are to each other. This particular few line script measures Levenshtein distance, but also
            normalizes it to the length of the longer string. A short name will have a small numeric measure of
            distance,
            even betweeen dissimilar strings, while long strings that are close overall can have a larger measure before
            normalization (depending on what measure is chosen, but for most of them). A few examples show this.</p>


        <pre class="input">%%bash 
similarity David Davin
</pre>

        <pre>Levenshtein distance: 1
Similarity ratio: 0.8
</pre>


        <pre class="input">%%bash
similarity David Maven
</pre>

        <pre>Levenshtein distance: 3
Similarity ratio: 0.4
</pre>


        <pre class="input">%%bash
similarity &quot;the quick brown fox jumped&quot; \
           &quot;thee quikc brown fax jumbed&quot;
</pre>

        <pre>Levenshtein distance: 5
Similarity ratio: 0.814814814815
</pre>

        <p>For this exercise, your goal is to identify every <em>genuine</em> name, and correct all the misspelled ones
            to
            the correct canonical spelling. Keep in mind that sometimes multiple legitimate names are actually close to
            each
            other in terms of similarity measures. However, it is probably reasonable to assume that <em>rare</em>
            spellings
            are typos, at least if they are also relatively similar to common spellings. You may use whatever
            programming
            language, library, and metric you feel is the most useful for the task.</p>

        <p>Reading in the data, we see it is similar to the human measures we have seen before.</p>


        <pre class="input">names = pd.read_csv(&#39;data/humans-names.csv&#39;)
names.head()
</pre>


        <table border="1">
            <thead>
                <tr style="text-align: right;">
                    <th></th>
                    <th>Name</th>
                    <th>Height</th>
                    <th>Weight</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>0</th>
                    <td>James</td>
                    <td>167.089607</td>
                    <td>64.806216</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>David</td>
                    <td>181.648633</td>
                    <td>78.281527</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>Barbara</td>
                    <td>176.272800</td>
                    <td>87.767722</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>John</td>
                    <td>173.270164</td>
                    <td>81.635672</td>
                </tr>
                <tr>
                    <th>4</th>
                    <td>Michael</td>
                    <td>172.181037</td>
                    <td>82.760794</td>
                </tr>
            </tbody>
        </table>

        <p>It is easy to see that some "names" occur very frequently and others only rarely. Look at the middling values
            as
            well in working on this exercise.</p>


        <pre class="input">names.Name.value_counts()
</pre>


        <pre>Elizabeth    1581
Barbara      1568
Jessica      1547
Jennifer     1534
             ... 
Josep           1
iWlliam         1
Joseeph         1
eJennifer       1
Name: Name, Length: 249, dtype: int64</pre>

    </div>
    <div class="hidden" id="8">
        <h2>Denouement</h2>

        <blockquote>
            <p>When you have eliminated the impossible, whatever remains,
                however improbable, must be the truth.<br />
                –Arthur Conan Doyle</p>
        </blockquote>

        <p><strong>Topics</strong>: Missing Data; Sentinels; Miscoded Data; Fixed Bounds; Outliers</p>

        <p>The anomalies that we have discussed in this chapter fall into a few relatively distinct categories. For the
            first kind, there are the special values that explicitly mark missing data, although those markers are
            sometimes
            subject to pitfalls. However, an explicit indication of missingness is probably the most straightforward
            kind of
            anomaly. A second kind of anomaly are categorical values that a miscoded; some finite number of values are
            proper (although not always clearly documented), and anything that isn't one of those few values is an
            anomaly.
        </p>

        <p>The third kind of anomaly is in continuous—or at least ranged—data values that fall outside of the bounds of
            our
            expectations. These are also called <em>outliers</em>, although exactly how much a value has to lie outside
            typical values to be a problem is very domain and problem dependent. Expectations may take the form of a
            priori
            that arise from domain knowledge of the measurement. They may also arise from the distribution of data
            within a
            variable overall, and the deviation of one particular value from others measured as that variable. At times,
            our
            expectations about bounds can even be multivariate, and some numeric combination of multiple variables
            produces
            a value outside of expectation bounds.</p>

        <p>For all of these kinds of anomalies, there are essentially two actions we might take. We may decide to
            discard an
            observation or sample altogether if it has one of these problems. Or alternately, we may simply more
            explicitly
            mark one feature within an observation as explicitly missing based on its value not being reliable. When we
            modify values to the "missing" special value, keeping track of our changes and data versions is extremely
            important practice. What we choose to do with those values marked as explicitly missing is a downstream
            decision
            that is discussed at more length in later chapters.</p>

        <p>In the next chapter we move from looking for problems with particular data points and into looking for
            problems
            with the overal “shape” of a data set.</p>
    </div>

    <!-- Bootstrap JS -->
    <script src="assets/js/bootstrap.min.js"></script>
    <script src="assets/js/wow-1.3.0.min.js"></script>
    <script src="assets/js/waypoints.js"></script>
    <script src="assets/js/jquery.scrollUp.js"></script>
    <script src="assets/js/active.js"></script>

</body>

</html>
