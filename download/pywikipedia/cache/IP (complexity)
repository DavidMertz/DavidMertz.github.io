In computational complexity theory, the class '''IP''' is the class of problems solvable by an [[interactive proof system]].  The concept of an interactive proof system was first introduced by Goldwasser, et al. in 1985. An interactive proof system consists of two machines, a prover, P, which presents a proof that a given string <math>n</math> is a member of some [[formal language|language]], and a verifier, V, that checks that the presented proof is correct. The prover is assumed to be infinite in computation and storage, while the verifier is a probabilistic polynomial-time machine with access to a random bit string whose length is polynomial on the size of <math>n</math>. These two machines exchange a polynomial number, <math>p(n)</math>, of messages and once the interaction is completed, the verifier must decide whether or not <math>n</math> is in the language, with only a 1/3 chance of error. (So any language in '''[[BPP]]''' is in '''IP''', since then the verifier could simply ignore the prover and make the decision on its own.)
More formally:<br>

For any language <math>L</math>, <math>L \in IP \Rightarrow \exists V, P | \forall Q, w</math>: 

* <math>w \in L \Rightarrow Pr[V \leftrightarrow P\ accepts\ w] \ge \frac{2}{3}</math>
* <math>w \not \in L \Rightarrow Pr[V \leftrightarrow Q accepts\ w] \le \frac{1}{3}</math>

The [[Arthur-Merlin protocol]], introduced by [[Laszlo Babai]], is similar in nature, except that the number of rounds of interaction is bounded by a constant rather than a polynomial.

Goldwasser et al have shown that ''public-coin'' protocols, where the random numbers used by the verifier are provided to the prover along with the challenges, are no more powerful than private-coin protocols. At most two additional rounds of interaction are required to replicate the effect of a private-coin protocol.

In the following section we prove that <math>IP = PSPACE</math>, an important theorem in computational complexity, which demonstrates that an interactive proof system can be used to decide whether a string is a member of a language in polynomial time, even though the traditional '''[[PSPACE]]''' proof may be exponentially long.

==Proof that IP = PSPACE==
In order to prove that '''IP''' and '''PSPACE''' are equal, we show that '''IP''' is a subset of '''PSPACE''' and also that '''PSPACE''' is a subset of '''IP''', and hence the two are equivalent.  In order to demonstrate that <math>IP \subseteq PSPACE</math>, we present a simulation of an interactive proof system by a polynomial space machine.  To prove that <math>PSPACE \subseteq IP</math>, we show that the '''PSPACE'''-complete language TQBF is in '''IP'''.  Both parts of the proof are adapted from Sipser.

===IP is a subset of PSPACE===
Let A be a language in '''IP'''.  Now, assume that on input w with length n, A's verifier V exchanges exactly <math>p=p(n)</math> messages.  We now construct a machine M that simulates V and is in '''PSPACE'''.  To do this, we define our machine as follows:

<math>Pr[V\ accepts\ w] = max_P Pr[V\ \leftrightarrow P accepts\ w]</math>

By the definition of <math>IP</math>, we have <math>Pr[V\ accepts\ w] \ge \frac{2}{3}</math> if <math>w \in A</math> and <math>Pr[V\ accepts\ w] \le \frac{1}{3}</math> if <math>w \not \in A</math>. <br>

Now, it must be shown that the value can be calculated in polynomial space.  Here we take <math>M_j</math> denote to denote this sequence of messages, <math>m_1\# \ldots \#m_j</math>, exchanged by the prover and the verifier, and we generalize the interaction of V and P to start with an arbitrary message stream <math>M_j</math>.  We take <math>(V \leftrightarrow P)(w,r,M_j) = accept</math> if <math>M_j</math> can be extended with the messages <math>m_{j+1}</math> through <math>m_p</math> such that:

* For <math>j \leq i < p</math>, where i is even, <math>V(w, r, M_i) = m_{i+1}</math>
* For <math>j \leq i < p</math>, where i is odd, <math>P(w, r, M_i) = m_{i+1}</math>
* The final message <math>m_p</math> in the message history is accept

In other words, when <math>i</math> is even, the verifier sends a message, when it is odd, the prover sends a message, and the final message is to accept.  The first two rules ensure that the message sequence is valid, and the third ensures that this message sequence leads to an accept.

Next, further generalizing the earlier definitions, and taking a random string <math>r</math> of length <math>p</math>, we define:

<math>Pr[V \leftrightarrow P\ accepts\ w\ starting\ at\ M_j] = Pr[(V \leftrightarrow P)(w,r,M_j) = accept] </math>

Now, we can define:

<math>Pr[V accepts\ w\ starting\ at\ M_j] = max_P Pr[V \leftrightarrow P\ accepts\ w\ starting\ at\ M_j] </math>

and for every <math>0 \leq j \leq p</math> and every message history <math>M_j</math>, we inductively define the function <math>N_{M_j}</math>:

<math>
N_{M_j} = 
\begin{cases}
  0: j = p\ and\ m_p = reject\\
  1: j = p\ and\ m_p = accept\\
  max_{m_{j+1}} N_{M_{j+1}}: j < p\ and\ j\ is\ odd\\
  wt-avg_{m_{j+1}} N_{M_{j+1}}: j < p\ and\ j\ is\ even\\
\end{cases}
</math>

where the term <math>wt-avg_{m_{j+1}}N_{M_{j+1}}</math> is defined as follows:

<math>wt-avg_{m_{j+1}}N_{M_{j+1}} = \sum_{m_{j+1}}(Pr_r[V(w,r,M_j)])</math>

where <math>Pr_r</math> is the probability taken over the random string <math>r</math> of length <math>p</math>.  This expression is the average of <math>N_{M_{j+1}}</math>, weighted by the probability that the verifier sent message <math>m_{j+1}</math>.

Take <math>M_0</math> to be the empty message sequence, here we will show that <math>N_{M_0}</math> can be computed in polynomial space, and that <math>N_{M_0} = Pr[V\ accepts\ w]</math>.  First, to compute <math>N_{M_0}</math>, an algorithm can recursively calculate the values <math>N_{M_j}</math> for every j and <math>M_j</math>.
Since the depth of the recursion is p, only polynomial space is necessary.  The second requirement is that we need <math>N_{M_0} = Pr[V accepts w]</math>, the value needed to determine whether w is in A.  We use induction to prove this as follows.

We must show that for every <math>0 \leq j \leq p</math> and every <math>M_j</math>, <math>N_{M_j} = Pr[V\ accepts\ w\ starting\ at M_j]</math>, and we will do this using induction on j.  The base case is to prove for <math>j = p</math>.  Then we will use induction to go from p down to 0.

The base case <math>(j = p)</math> is fairly simple.  Since <math>m_p</math> is either accept or reject, if <math>m_p</math> is accept, <math>N_{M_p}</math> is defined to be 1 and Pr[V accepts w starting at <math>M_j</math>] = 1 since the message stream indicates acceptance, thus the claim is true.  If <math>m_p</math> is reject, the argument is very similar.

For the inductive hypothesis, we assume that for some <math>j + 1 \leq p</math> and any message sequence <math>M_{j+1}</math>, <math>N_{M_{j+1}} = Pr[V\ accepts\ w\ starting\ at\ j+1]</math> and then prove the hypothesis for <math>j</math> and any message sequence <math>M_j</math>.

If j is even, <math>m_{j+1}</math> is a message from V to P.  By the definition of <math>N_{M_j}</math>, <math>N_{M_j} = \sum_{m_{j+1}}(Pr_r[V(w,r,M_j)=m_{j+1}] N_{M_{j+1}})</math>.  Then, by the inductive hypothesis, we can say this is equal to <math>\sum_{m_{j+1}}(Pr_r[V(w,r,M_j)=m_{j+1}] * Pr[V\ accepts\ w\ starting\ at\ M_{j+1}])</math>.  Finally, by definition, we can see that this is equal to <math>Pr[V\ accepts\ w\ starting\ at\ M_j]</math>.

If j is odd, <math>m_{j+1}</math> is a message from P to V.  By definition, <math>N_{M_j} = max_{m_{j+1}} N_{M_{j+1}}</math>.  Then, by the inductive hypothesis, this equals <math>max_{m_{j+1}} * Pr[V\ accepts\ w\ starting\ at\ M_{j+1}]</math>.  This is equal to <math>Pr[V\ accepts\ w\ starting\ at\ M_j]</math> since:

<math>max_{m_{j+1}} Pr[V\ accepts\ w\ starting\ at\ M_{j+1}] \leq Pr[V\ accepts\ w\ starting\ at\ M_j]</math>

because the prover on the right-hand side could send the message <math>m_{j+1}</math> to maximize the expression on the left-hand side. And:

<math>max_{m_{j+1}} Pr[V\ accepts\ w\ starting\ at\ M_{j+1}] \geq Pr[V\ accepts\ w\ starting\ at\ M_j]</math>

Since the same Prover cannot do any better than send that same message.  Thus, this holds whether <math>i</math> is even or odd and the proof that '''IP''' <math>\subseteq</math> '''PSPACE''' is complete.

Here we have constructed a polynomial space machine that uses the best prover <math>P</math> for a particular string <math>w</math> in language <math>A</math>.  We use this best prover in place of a prover with random input bits because we are able to try every set of random input bits in polynomial space.
Since we have simulated an interactive proof system with a polynomial space machine, we have shown that '''IP''' <math>\subseteq</math> '''PSPACE''', as desired.<br>

<math>\Box</math>

===PSPACE is a subset of IP===

In order to illustrate the technique that will be used to prove <math>PSPACE \subseteq IP</math>, we will first prove a weaker theorem, which was proven by Lund, et al.: <math>\#SAT \in PSPACE</math>.  Then using the concepts
from this proof we will extend it to show that <math>TQBF \in PSPACE</math>. Since TQBF <math>\in</math> PSPACE-Complete, and <math>TQBF \in IP</math> then PSPACE <math>\subseteq</math> IP.

====#SAT is a member of IP====
We begin by showing that <math>\#SAT \in IP</math>, where: <br>

<math>\#SAT = \{ \langle \phi, k \rangle \mid \phi</math> is a cnf-formula with exactly <math>k</math> satisfying assignments <math>\}</math>.<br> 

Note that this is different from the normal definition of [[Sharp-P|#SAT]], in that it is a decision problem, rather than a function.

First we use arithmetization to map the boolean formula with <math>n</math> variables, <math>\phi(b_1, b_2, ..., b_n)</math> to a polynomial <math>p_\phi(x_1, x_2, ..., x_n)</math>, where <math>p_\phi</math> mimics <math>\phi</math> in that <math>p_\phi</math> is 1 if <math>\phi</math> is true and 0 otherwise provided that the variables of <math>p_\phi</math> are assigned Boolean values.  The Boolean operations <math>\vee</math>, <math>\wedge</math>, and <math>\neg</math> used in <math>\phi</math> are simulated in <math>p_\phi</math> by replacing the operators in <math>\phi</math> as shown in the table below.

{| border="1" cellpadding="2"
|<math>a \wedge b</math> ||  <math> ab</math>
|-
|<math>a \vee b</math>  || <math> a*b =_{def} 1 - (1 - a)(1 - b) </math>
|-
|<math>\neg a</math> || <math>1 - a</math>
|+ Arithmetization rules for converting a Boolean formula <math>\phi(b_1, b_2, ..., b_n)</math> to a polynomial <math>p_\phi(x_1, x_2, ..., x_n)</math>
|}

As an example, <math>\phi = a \wedge b \vee \neg c</math> would be converted into a polynomial as follows:

* <math> p_\phi = a \wedge b \vee \neg c </math>
* <math> p_\phi = a \wedge (1 - (1-b)(1-(1-c))) </math>
* <math> p_\phi = a (1 - (1-b)c) </math>
* <math> p_\phi = a - (ac-abc) </math>

The operations <math>ab</math> and <math>a*b</math> each result in a polynomial with a degree bounded by the sum of the degrees of the polynomials for <math>a</math> and <math>b</math> and hence, the degree of any variable is at most the length of <math>\phi</math>.

Now let <math>F</math> be a finite field with order <math>q > 2^n</math>; also demand that q be at least 1000. For each <math>0\leq i\leq n</math>, define a function <math>f_i</math> on F, having parameters <math>a_1, ..., a_{i-1}\in F</math>, and a single variable <math>a_i\in F</math>: For <math>0 \leq i \leq n</math> and for <math>a_1, ..., a_i \in F</math> let <math>f_i(a_1, ..., a_i) = \Sigma _{a_{i+1}, ..., a_n \in \{0, 1\}} p(a_1, ..., a_n)</math>.  Note that the value of <math>f_0</math> is the number of satisfying assignments of <math>\phi</math>. <math>f_0</math> is a void function, with no variables.

Now the protocol for <math>\#SAT</math> works as follows:

* '''Phase 0''':<br> The prover <math>P</math> choses a prime <math>q > 2^n</math> and computes <math>f</math>, it then sends <math>q</math> and <math>f_0()</math> to the verifier <math>V</math>.  <math>V</math> checks that <math>q</math> is a prime greater than <math>max(1000, 2^n)</math> and that <math>f_0() = k</math>.
* '''Phase 1''':<br> <math>P</math> sends the coefficients of <math>f_1(z)</math> as a polynomial in z.  <math>V</math> verifies that the degree of <math>f_1</math> is less than <math>n</math> and that <math>f_0 = f_1(0) + f_1(1)</math>.  (If not <math>V</math> rejects).  <math>V</math> now sends a random number <math>r_1</math> from <math>F</math> to <math>P</math>.
* '''Phase i''':<br> <math>P</math> sends the coefficients of <math>f_i(r_1, ..., r_{i-1}, z)</math> as a polynomial in <math>z</math>.  <math>V</math> verifies that the degree of <math>f_i</math> is less than <math>n</math> and that <math>f_{i-1}(r_1, ..., r_{i-1}) = f_i(r_1, ..., r_{i-1}, 0) + f_i(r_1, ..., r_{i-1}, 1)</math>.  (If not <math>V</math> rejects).  <math>V</math> now sends a random number <math>r_i</math> from <math>F</math> to <math>P</math>.
* '''Phase n+1''':<br> <math>V</math> evaluates <math>p(r_1, ..., r_n)</math> to compare to the value <math>f_n(r_1, ..., r_n)</math>.  If they are equal <math>V</math> accepts, otherwise <math>V</math> rejects.

Note that this is a public-coin algorithm.

If <math>\phi</math> has <math>k</math> satisfying assignments, clearly <math>V</math> will accept.  If <math>\phi</math> does not have <math>k</math> satisfying assignments we assume there is a prover <math>\tilde P</math> that tries to convince <math>V</math> that <math>\phi</math> does have <math>k</math> satisfying assignments.  We show that this can only be done with low probability.

To prevent <math>V</math> from rejecting in phase 0, <math>\tilde P</math> has to send an incorrect value <math>\tilde f_0()</math> to <math>P</math>.  Then, in phase 1, <math>\tilde P</math> must send an incorrect polynomial <math>\tilde f_1</math> with the property that <math>\tilde f_1(0)+\tilde f_1(1) = \tilde f_0()</math>. When <math>V</math> chooses a random <math>r_1</math> to send to <math>P</math>, <math>Pr[\tilde f_1(r_1) = f_1(r_1)] < n^{-2}</math>.  This is because a polynomial in a single variable of degree at most <math>d</math> can have no more than <math>d</math> roots (unless it always evaluates to 0).  So, any two polynomials in a single variable of degree at most <math>d</math> can be equal only in <math>d</math> places.  Since <math>|F| > 2^n</math> the chances of <math>r_1</math> being one of these values is at most <math>n/2^n < n/n^3</math> if n > 10, or at most <math>n/1000 \leq n/n^3</math> if <math>n \leq 10</math>.

Generalizing this idea for the other phases we have for each <math>1 \leq i \leq n</math> if <math>\tilde f_{i-1}(r_1, ..., r_{i-1}) \not=f_{i-1}(r_1, ..., r_{i-1})</math>, then for <math>r_i</math> chosen randomly from <math>F</math>, <math>Pr[\tilde f(r_1, ..., r_i) = f_i(r_1, ..., r_i)] \leq n^{-2}</math>.  There are <math>n</math> phases, so the probability that <math>\tilde P</math> is lucky because <math>V</math> selects at some stage a convenient <math>r_i</math> is at most <math>1/n</math>.  So, no prover can make the verifier accept with probability greater than <math>1/n</math>.  We can also see from the definition that the verifier <math>V</math> operates in probabilistic polynomial time.  Thus, <math>\#SAT \in IP</math>.

====TQBF is a member of IP====
In order to show that '''PSPACE''' is a subset of '''IP''', we need to choose a '''PSPACE-Complete''' problem and show that it is in '''IP'''. Once we show this, then it clear that '''PSPACE''' <math>\subseteq</math> '''IP'''.  The proof technique demonstrated here is credited to [[Adi Shamir]]

We know that TQBF is in '''PSPACE-Complete'''.  So let <math>\psi</math> be a quantified boolean expression:

<math>\psi = Q_1 x_1 Q_2x_2...Q_mx_m[\phi]</math> 

where <math>\phi</math> is a CNF formula.  Then <math>Q_i</math> is a quantified, either <math>\exists</math> or <math>\forall</math>. Now <math>f_i</math> is the same as in the previous proof, but now it also includes quantifiers.

<math>f_i(a_1, ..., a_i) = 
\begin{cases}
f_i(a_1, a_2,...a_m) =  1~if~ Q_{i+1}x_{i+1}...Q_mx_m[\phi(a_1,a_2...a_i)]~is~true\\
0~otherwise
\end{cases}
</math>

Here, <math>\phi(a_1,a_2,...,a_i)</math> is <math>\phi</math>  with <math>a_1</math> to <math>a_i</math> substituted for <math>x_1</math> to <math>x_i</math>. Thus <math>f_0()</math> is the truth value of <math>\psi</math>. In order to arithmetize <math>\psi</math> we must use the following rules:
<math>If\ Q_{i+1} = \forall , f_i(a_1,a_2,....a_i) = f_{i+1}(a_1,a_2,...,a_i,0)\cdot f_{i+1}(a_1,a_2,...,a_i,1)</math>

<math>If\ Q_{i+1} = \exists, f_i(a_1,a_2,....a_i) = f_{i+1}(a_1,a_2,...,a_i,0) * f_{i+1}(a_1,a_2,...,a_i,1) </math>

where as before we define x * y = 1-(1-x)(1-y).

By using the method described in <math>\#SAT</math>, we must face a problem that for any <math>f_i</math> the degree of the resulting polynomial may double with each quantifier. In order to prevent this, we must introduce a new reduction operator R which will reduce the degrees of the polynomial without changing their behavior on Boolean inputs.

So now before we arithmetize <math>\psi = Q_1 x_1 Q_2x_2...Q_mx_m[\phi]</math> we introduce a new expression:

<math>\psi' = Q_1 R_{x_1} Q_2 R_{x_2}...Q_m R_{x_m}[\phi]</math>

Or written another way:

<math>\psi' = S_1 y_1 S_2 y_2...S_m y_m[\phi], where\ S_i \in \{ \forall ,\exists , R\}, and\ y_i \in \{ x_1,x_2,...x_m\}</math>

Now for every i <math>\leq</math> k we define the function <math>f_i</math>. We also define <math>f_k(x_1,x_2,....x_m)</math> to be the polynomial <math>p(x_1,x_2,...x_m)</math> which is obtained by arithmetizing <math>\phi</math>. Now in order to keep the degree of the polynomial low, we define <math>f_i</math> in terms of <math>f_{i+1}</math>:

<math>If\ S_{i+1} = \forall, f_i(a_1,a_2,....a_i) = f_{i+1}(a_1,a_2,....a_i,0)\cdot f_{i+1}(a_1,a_2,....a_i,1) </math>

<math>If\ S_{i+1} = \exists, f_i(a_1,a_2,....a_i) = f_{i+1}(a_1,a_2,....a_i,0) * f_{i+1}(a_1,a_2,....a_i,1) </math>

<math>If\ S_{i+1} = R, f_i(a_1,a_2,....a_i,a) =  (1-a)f_{i+1}(a_1,a_2,....a_i,0) + a f_{i+1}(a_1,a_2,....a_i,1)
</math>

Now we can see that the reduction operation R, doesn't change the degree of the polynomial. Also it is important to see that the <math>R_x</math> operation doesn't change the value of the function on boolean inputs. So <math>f_0</math> is still the truth value of <math>\psi</math>, but the <math>R_x</math> value produces a result that is linear in x. Also after any <math>Q_ix_i</math> we add <math>R_{x_1}...R_{x_i}</math> in <math>\psi'</math> in order to reduce the degree down to 1 after arithmetizing <math>Q_i</math>.

Now let's describe the protocol. If <math>n</math> is the length of <math>\psi</math>, all arithmetic operations in the protocol are over a field of size at least <math>n^4</math> where <math>n</math> is the length of <math>\psi</math>.

* '''Phase 0''':
<math>P \rightarrow V</math>: P sends <math>f_0</math> to V.  V checks that <math>f_0 = 1</math> and rejects if not.
* '''Phase 1''':<br> 
<math>P \rightarrow V</math>: P sends <math>f_1(z)</math> to V.  V uses coefficients to evaluate <math>f_1(0)</math> and <math>f_1(1)</math>. Then it checks that the polynomial's degree is at most <math>n</math> and that the following identities are true:

*<math>f_{0}() = 
\begin{cases}
\ f_{1}(0)\cdot f_{1}(1) ~if~ S = \forall \\
f_{1}(0) * f_{1}(1) ~if~ S = \exists. 
\end{cases}</math>
* <math>f_{0}() = (1-r)f_{1}(0) + rf_{1}(1) ~if~ S = R.</math>

If either fails then reject.

* '''Phase i''':
<math>P \rightarrow V</math>: P sends <math>f_i(r_1,r_2...r_{i-1},z)</math> as a polynomial in <math>z</math>.  <math>r_1</math> denotes the previously set random values for <math>r_1,r_2...r_{i-1}</math>

V uses coefficients to evaluate <math>f_i(r_1,r_2...r_{i-1},0)</math> and <math>f_i(r_1,r_2...r_{i-1},1)</math>.  Then it checks that the polynomial degree is at most <math>n</math> and that the following identities are true:
* <math>f_{i-1}(r_1,r_2...r_{i-1}) = \{
f_{i}(r_1,r_2...r_{i-1},0)\cdot f_{i}(r_1,r_2...r_{i-1},1) ~if~
S = \forall.</math>
* <math>f_{i}(r_1,r_2...r_{i-1},0) * f_{i}(r_1,r_2...r_{i-1},1) ~if~
S = \exists.</math>
* <math>f_{i-1}(r_1...r) = (1-r)f_{i}(r_1,r_2...r_{i-1},0) +
rf_{i}(r_1,r_2...r_{i-1},1) ~if~ S = R.</math>If either fails then reject.

<math>V \rightarrow P</math>: V picks a random <math>r</math> in <math>F</math> and sends it to P. (If S=R then this <math>r</math> replaces the previous <math>r</math>). 

Goto phase i+1 where P must persuade V that <math>f_i(r_1,...,r)</math> is correct.


* '''Phase k+1''':<br> 
V evaluates <math>p(r_1,r_2,...,r_m)</math>. Then it checks if <math>p(r_1,r_2,...,r_m) = f_k(r_1,r_2,....r_m)</math> If they are equal then V accepts, otherwise V rejects.

This is the end of the protocol description.

If <math>\psi</math> is true then V will accept when P follows the protocol. Likewise if <math> \tilde{P} </math> is a malicious prover which lies, and if <math>\psi</math> is false, then <math> \tilde{P} </math> will need to lie at phase 0 and send some value for <math>f_0</math>. If at phase i, V has an incorrect value for
<math>f_{i-1}(r_1,...)</math> then <math>f_i(r_1,...0)</math> and <math>f_i(r_1,...1)</math> will likely also be incorrect, and so forth. The probability for <math> \tilde{P} </math> to get lucky on some random <math>r</math> is at most the degree of the polynomial divided by the field size: <math>n/n^4</math>.  The protocol runs through <math>O(n^2)</math> phases, so the probability that <math> \tilde{P} </math> gets lucky at some
phase is <math>\leq \frac{1}{n}</math>. If <math> \tilde{P} </math> is never lucky, then V will reject at phase k+1.

Since we have now shown that both '''IP''' <math>\subseteq</math> '''PSPACE''' and '''PSPACE''' <math>\subseteq</math> '''IP''', we can conclude that '''IP''' = '''PSPACE''' as desired. Moreover, we have shown that any '''IP''' algorithm may be taken to be public-coin, since the reduction from '''PSPACE''' to '''IP''' has this property.

<math>\Box</math>

== Variants ==

There are a number of variants of '''IP''' which slightly modify the definition of the interactive proof system. We summarize some of the more well-known ones here.

=== MIP ===
''Main article: [[Interactive proof system#MIP]]''

In 1988, Goldwasser et al. created an even more powerful interactive proof system based on '''IP''' called '''MIP''' in which there are ''two'' independent provers. The two provers cannot communicate once the verifier has begun sending messages to them. Just as it's easier to tell if a criminal is lying if he and his partner are interrogated in separate rooms, it's considerably easier to detect a malicious prover trying to trick the verifier if there is another prover it can double-check with. In fact, this is so helpful that Babai, Fortnow, and Lund were able to show that '''MIP''' = '''NEXPTIME''', the class of all problems solvable by a [[nondeterministic Turing machine|nondeterministic]] machine in ''exponential time'', a very large class. Moreover, all languages in '''NP''' have zero-knowledge proofs in an '''MIP''' system, without any additional assumptions; this is only known for '''IP''' assuming the existence of one-way functions.

=== IPP ===

'''IPP''' (''unbounded IP'') is a variant of '''IP''' where we replace the '''[[BPP]]''' verifier by a '''[[PP (complexity)|PP]]''' verifier. More precisely, we modify the completeness and soundness conditions as follows:

* '''Completeness''': if a string is in the language, the honest verifier will be convinced of this fact by an honest prover with probability at least 1/2.
* '''Soundness''': if the string is not in the language, no prover can convince the honest verifier that it is in the language, except with probability less than 1/2.

Although '''IPP''' also equals '''PSPACE''', '''IPP''' protocols behaves quite differently from '''IP''' with respect to [[oracle machine|oracles]]: '''IPP'''='''PSPACE''' with respect to all oracles, while '''IP''' &ne; '''PSPACE''' with respect to almost all oracles.
<ref> R. Chang, B. Chor, Oded Goldreich, J. Hartmanis, J. Håstad, D. Ranjan, and P. Rohatgi. [http://citeseer.ist.psu.edu/chang97random.html The random oracle hypothesis is false]. ''Journal of Computer and System Sciences'', 49(1):24-39. 1994. </ref>

=== QIP ===

'''QIP''' is a version of '''IP''' replacing the '''[[BPP]]''' verifier by a '''[[BQP]]''' verifier, where '''BQP''' is the class of problems solvable by [[quantum computer]]s in polynomial time. The messages are composed of qubits.<ref>J. Watrous. [http://citeseer.ist.psu.edu/watrous99pspace.html PSPACE has constant-round quantum interactive proof systems]. ''Proceedings of IEEE FOCS'99'', pp. 112-119. 1999.</ref> It is not yet known if '''QIP''' strictly contains '''IP''' (that is, whether quantum computation adds power to interactive proofs), but it is known that '''QIP''' = '''QIP'''[3], so that more than three rounds are never necessary. Also, '''QIP''' is contained in '''[[EXPTIME]]'''.<ref>A. Kitaev and J. Watrous. [http://www.cpsc.ucalgary.ca/~jwatrous/papers/qip2.ps Parallelization, amplification, and exponential time simulation of quantum interactive proof systems]. ''Proceedings of ACM STOC'2000'', pp. 608-617. 2000. </ref>

=== compIP ===

Whereas '''IPP''' and '''QIP''' give more power to the verifier, a '''compIP''' system (''competitive IP proof system'') weakens the completeness condition in a way that weakens the prover:

* '''Completeness''': if a string is in the language ''L'', the honest verifier will be convinced of this fact by an honest prover with probability at least 2/3. Moreover, the prover will do so in probabilistic polynomial time given access to an oracle for the language ''L''.

Essentially, this makes the prover a '''[[BPP]]''' machine with access to an oracle for the language, but only in the completeness case, not the soundness case. The concept is that if a language is in '''compIP''', then interactively proving it is in some sense as easy as deciding it. With the oracle, the prover can easily solve the problem, but its limited power makes it much more difficult to convince the verifier of anything. In fact, '''compIP''' isn't even known or believed to contain '''[[NP (complexity)|NP]]'''.

On the other hand, such a system can solve some problems believed to be hard. In can easily solve all '''[[NP-complete]]''' problems due to self-reducibility. Additionally, our earlier proof that graph nonisomorphism is in '''IP''' also shows that it is in '''compIP''', since the only hard operation the prover ever does is isomorphism testing, which it can use the oracle to solve. Quadratic non-residuosity and graph isomorphism are also in '''compIP'''.<ref> Shafi Goldwasser and Mihir Bellare. [http://www.cs.ucsd.edu/users/mihir/papers/compip.pdf The Complexity of Decision versus Search]. ''SIAM Journal on Computing'', Volume 23, No. 1. February 1994. </ref>

== Additional Sources ==

* Babai, L. Trading group theory for randomness. In Proceedings of the 17th ACM Symposium on the  Theory of Computation . ACM, New York, 1985, pp. 421-429.

* Shafi Goldwasser, Silvio Micali, and Charles Rackoff. [http://portal.acm.org/citation.cfm?id=63434 The Knowledge complexity of interactive proof-systems]. ''Proceedings of 17th ACM Symposium on the Theory of Computation'', Providence, Rhode Island. 1985, pp. 291-304. [http://theory.lcs.mit.edu/~cis/pubs/shafi/1985-stoc.pdf Extended abstract]

* Shafi Goldwasser and Michael Sipser. [http://theory.lcs.mit.edu/~cis/pubs/shafi/1986-stoc.pdf Private coins versus public coins in interactive proof systems]. ''Proceedings of the 18th Annual ACM Symposium on Theory of Computation''. ACM, New York, 1986, pp. 59-68.

* Lund, C., Fortnow, L.. Karloff, H., Nisan, N. Algebraic methods for interactive proof systems. In Proceedings of 31st Symposium on the Foundations of Computer Science. IEEE, New York, 1990, pp. 2-90.

* Adi Shamir. [http://portal.acm.org/citation.cfm?doid=146585.146609 IP = PSPACE]. ''Journal of the ACM'', volume 39, issue 4, p.869-877. October 1992.

* Sipser, Michael. "Introduction to the Theory of Computation", Boston, 1997, pg. 392-399.

* Complexity Zoo: [http://qwiki.caltech.edu/wiki/Complexity_Zoo#ip IP], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#mip MIP], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#ipp IPP], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#qip QIP], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#qip2 QIP(2)], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#compip compIP], [http://qwiki.caltech.edu/wiki/Complexity_Zoo#frip frIP]


<!--See http://en.wikipedia.org/wiki/Wikipedia:Footnotes for an explanation of how to generate footnotes using the <ref(erences/)> tags-->
<references/>

{{ComplexityClasses}}

[[Category:Complexity classes]]