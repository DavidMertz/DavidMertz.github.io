<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>David Mertz Conference Speaking</title>
</head>

<body>
  <h2>David Mertz Conference Speaking</h2>

  <h3>Summary</h3>
  <ol>
    <li>OSCon 2006, 
      <i>Open Source Voting</i></li>
    <li>OSCon 2007, 
      <i>Open Source Voting (revisited)</i></li>
    <li>Pycon 2010, 
      <i>Maximize your program's laziness</i></li> 
    <li>PyCon 2012, 
      <i>Coroutines, event loops, and the history of Python generators</i></li>
    <li>OSCon 2012, 
      <i>US Patriot Act and implications for Cloud Computing &amp; Data Privacy</i></li>
    <li>PyCon-India 2012, 
      <i>Keynote Address</i></li>
    <li>PyCon 2013,
      <i>Why you should use Python 3 for text processing</i></li>
  </ol>

<hr/>
<!-- ====================================================================== -->

  <h3>OSCon 2006</h3>
  <h4>Open Source Voting</h4>
  
  <p>About: <a href=
    "http://conferences.oreillynet.com/cs/os2006/view/e_sess/8606">
    http://conferences.oreillynet.com/cs/os2006/view/e_sess/8606</a></p>

  <p><a href=
  "http://conferences.oreillynet.com/cs/os2006/view/e_spkr/2781">Arthur
  Keller</a>, University of California, Santa Cruz<br/>
  <a href=
  "http://conferences.oreillynet.com/cs/os2006/view/e_spkr/2812">David
  Mertz</a>, CTO, Open Voting Consortium</p>

  <p>The hanging chads of 2000 showed that America's voting systems were
  out of date and unreliable. Yet, the electronic voting systems widely
  adopted since then are even worse. In the 2004 elections, nearly 50
  million votes existed only in alterable electronic form. The software
  that processed them would have made tampering easy. Both the election
  data and the software were hidden from public view. There were serious
  allegations of fraud, but no possibility of a public audit to resolve
  them.</p>

  <p>Electoral fraud disenfranchises everyone. To preserve the right to
  vote, the Open Voting Consortium (OVC) is working to establish a voting
  system worthy of public trust. While protecting voter anonymity, this
  Open Voting system makes all data and software auditable, publicly
  inspectable, permanent, and tamper-proof. The proposed project will
  develop the software and data systems needed to tabulate countywide
  voting. This project is a vital enabling step in a larger campaign,
  teaming OVF and OVC with government, business, and universities, to make
  open voting the norm in American elections.</p>

  <p>In April 2004, OVC publicly demonstrated an open source precinct
  voting system. The system included:</p>

  <ol>
    <li>an electronic voting machine, accessible through either a touch
    screen or an auditory interface, which printed paper ballots and
    maintained an electronic audit trail,</li>

    <li>a ballot verification system that allowed the visually impaired to
    hear the selections on their ballots, and</li>

    <li>a ballot reconciliation system that compared the paper ballots with
    the electronic audit trail, and accounted for spoiled ballots.</li>
  </ol>

  <p>We are developing a secure, reliable, auditable vote tabulation system
  that covers five main functions: security, auditing, vote tabulation,
  bulk optical ballot scanning, and web-based vote tally reporting.</p>
  
<hr/>
<!-- ====================================================================== -->

  <h3>OSCon 2007</h3>
  <h4>Open Source Voting</h4>
  
  <p>About: <a href=
  "http://conferences.oreillynet.com/cs/os2006/view/e_sess/8606">
  http://conferences.oreillynet.com/cs/os2006/view/e_sess/8606</a></p>

  <p><a href="http://conferences.oreillynet.com/cs/os2007/view/e_spkr/2781">
  Arthur Keller</a>, University of California, Santa Cruz<br/>
  <a href="http://conferences.oreillynet.com/cs/os2007/view/e_spkr/3919">
  Fred McLain</a><br/>
  <a href="http://conferences.oreillynet.com/cs/os2007/view/e_spkr/2812">
  David Mertz</a>, CTO, Open Voting Consortium</p>

  <p>The hanging chads of 2000 showed that America's voting systems were
  out of date and unreliable. Yet, the electronic voting systems widely
  adopted since then are even worse. In the 2004 elections, nearly 50
  million votes existed only in alterable electronic form. Suspicious
  undervotes on the electronic voting machines affected the outcome of
  several congressional elections in 2006. The software that processed them
  would have made tampering easy. Both the election data and the software
  were hidden from public view. There were serious allegations of fraud,
  but no possibility of a public audit to resolve them.</p>

  <p>Electoral fraud disenfranchises everyone. To preserve the right to
  vote, the Open Voting Consortium (OVC) is working to establish a voting
  system worthy of public trust. While protecting voter anonymity, this
  Open Voting system makes all data and software auditable, publicly
  inspectable, permanent, and tamper-proof. The proposed project will
  develop the software and data systems needed to tabulate countywide
  voting. This project is a vital enabling step in a larger campaign,
  teaming OVF and OVC with government, business, and universities, to make
  open voting the norm in American elections.</p>

  <p>In April 2004, OVC publicly demonstrated an open source precinct
  voting system. The system included:</p>

  <ol>
    <li>An electronic voting machine, accessible through either a touch
    screen or an auditory interface, that printed paper ballots and
    maintained an electronic audit trail,</li>

    <li>A ballot verification system that allowed the visually impaired to
    hear the selections on their ballots, and</li>

    <li>A ballot reconciliation system that compared the paper ballots with
    the electronic audit trail, and accounted for spoiled ballots.</li>
  </ol>

  <p>We will update last year's presentation with progress in the
  development of a secure, reliable, auditable vote tabulation system that
  covers five main functions: security, auditing, vote tabulation, bulk
  optical ballot scanning, and web-based vote tally reporting.</p>
  
<hr/>
<!-- ====================================================================== -->

  <h3>Pycon 2010</h3>
  <h4>Maximize your program's laziness</h4>

  <p>Video: <a href=
  "http://www.talkminer.com/viewtalk.jsp?videoid=bliptv3259746&amp;q=">
  http://www.talkminer.com/viewtalk.jsp?videoid=bliptv3259746&amp;q=</a></p>

  <p>Slides: <a href=
  "http://gnosis.cx/publish/Laziness.pdf">http://gnosis.cx/publish/Laziness.pdf</a></p>

  <p>David Mertz</p>

  <h5>Summary</h5>

  <p>The cheapest, fastest and most reliable components of a computer
  system are those that aren't there" has a parallel in data structures.
  &nbsp;The fastest, most parsimonious, &nbsp;and best performing data
  structure is one which is never concretized within a program run. &nbsp;A
  promise to create data when, or if, it is needed is often easy to make
  without needing to realize the data computationally.</p>

  <p>The addition of iterators and generators to Python during the 2.x
  series, and their more systematic use in 3.x, provides an easy way to
  work with lazy computation. &nbsp;Using these facilities well can improve
  program performance, often in terms of big-O complexity even.
  &nbsp;However, sometimes more complex lazy data structures require
  special design in order to encapsulate more complex promises than one can
  make with list-like iterators.</p>

  <h5>Description</h5>

  <p>Talk outline</p>
  <ol>
    <li>5 minute review of laziness, with examples from functional
        programming language(s).</li>
    <li>8 minute review of iterators and itertools.</li>
    <li>3 minute review of generators and generator expressions.</li>
    <li>3 minute review of memoization and weakrefs.</li>
    <li>10 minute case study on laziness in computation components in
        acyclical direct graph.</li>
    <li>1 minute wrap up of miscellaneous exoterica.<br /></li>
  </ol>
  
<hr />
<!-- ====================================================================== -->

  <h3>PyCon 2012<h3>
  <h4>Coroutines, event loops, and the history of Python generators</h4>
  
  <p>Slides: <a href="http://gnosis.cx/publish/Laziness.pdf">
  http://gnosis.cx/publish/Generators.pdf</a></p>

  <p>Video: <a href=
  "http://pyvideo.org/video/668/coroutines-event-loops-and-the-history-of-pytho">
  http://pyvideo.org/video/668/coroutines-event-loops-and-the-history-of-pytho</a></p>

  <p><a href="https://us.pycon.org/2012/speaker/profile/135/">David
  Mertz</a></p>

  <h5>Description</h5>

  <p>This talk traces lightweight concurrency from Python 2.2's generators,
  which enabled semi-coroutines as a mechanism for scheduling "weightless"
  threads; to PEP 342, which created true coroutines, and hence made
  event-driven programming easier; to 3rd party libraries built around
  coroutines, from older GTasklet and peak.events to the current
  Greenlet/gevent and Twisted Reactor.</p>

  <h5>Abstract</h5>

  <p>This talk aims to provide both a practical guide and theoretical
  underpinnings to the use of generator-based lightweight concurrency in
  Python.</p>

  <ol>
    <li>Lightning tour of generator constructs. Why generator-based
        scheduling is particularly useful for event-based programming.</li>
    <li>Simple example of a "trampoline" or scheduler.</li>
    <li>Slightly fleshed out example of scheduler with discussion of
        data-passing issues.</li>
    <li>Examples using GTasklet to make coroutine code look more like
        familiar sequential code (the framework is based on greenlets rather
        than generators, but accomplishes similar purpose).</li>
    <li>Brief examples of Twisted Reactors and Deferreds.</li>
    <li>Limits of generator-based concurrency (i.e. doesn't help with
        multiple cores and multiple servers). "Throw at the wall" list of ways
        to generalize to larger scales than single cores.</li>
  </ol>

<hr/>
<!-- ====================================================================== -->

  <h3>OSCon 2012</h3>
  <h4>US Patriot Act and implications for Cloud Computing &amp; Data Privacy</h4>
  
  <p>About: <a href=
  "http://www.oscon.com/oscon2012/public/schedule/detail/23880">
  http://www.oscon.com/oscon2012/public/schedule/detail/23880</a></p>
  <p>Slides:
    <ul>
      <li><a href=
"http://cdn.oreillystatic.com/en/assets/1/event/80/US%20Patriot%20Act%20and%20implications%20for%20Cloud%20Computing%20_%20Data%20Privacy%20%20Presentation.pdf">
          Diane Mueller slides</a></li>
      <li><a href="http://gnosis.cx/oscon_2012/Paranoia.pdf">
          David Mertz slides</a></li>
      <li><a href="http://gnosis.cx/oscon_2012/">
          Archive/audio at gnosis.cx</a></li>
    </ul>
  </p>

  <p><a href="http://www.oscon.com/oscon2012/public/schedule/speaker/92956">
  Diane Mueller</a> (ActiveState),<br/>
  <a href="http://www.oscon.com/oscon2012/public/schedule/speaker/27225">
  David Mertz</a> (IBM developerWorks)</p>

  <p>Is the US Patriot Act causing you to hesitate on leveraging the cloud
  in your enterprise? Do you want to leverage the power of cloud computing
  but unsure what the security and privacy implications are for sensitive
  corporate data?</p>

  <p>Organizations are thinking long and hard about the legal and
  regulatory implications of cloud computing. When it comes to actual
  corporate data, no matter what the efficiency gains are, legal
  departments are often directing IT departments to steer clear of any
  service that eliminates their ability to keep potential sensitive
  information out of the hands of Federal prosecutors.</p>

  <p>Despite all the hype about every application moving into the cloud,
  some practical patterns are starting to emerge in the types of data
  corporations are willing to move to the cloud. Learn how to create a
  secure, compliant, private platform and cloud for developing,
  distributing and managing enterprise applications.</p>

  <p>I will cover: Introduction to the US Patriot Act and Data Privacy
  issues Implications for on Cloud Computing Jurisdictional Issues Best
  Practices &amp; Practical Patterns Classes of applications that best
  leverage the cloud What types of applications should stay on-premise
  Private Cloud Model(s) Building a Compliant Cloud Strategy</p>

<hr/>
<!-- ====================================================================== -->

  <h3>PyCon-India 2012</h3>
  <h4>Keynote Address</h4>

  <p>Video: <a href="http://www.youtube.com/watch?v=EJseJV6RLUg">
  http://www.youtube.com/watch?v=EJseJV6RLUg</a></p>

  <p>Slides: <a href=
  "http://www.slideshare.net/LuluLotus/election-security">
  http://www.slideshare.net/LuluLotus/election-security</a></p>

<hr/>
<!-- ====================================================================== -->

  <h3>PyCon 2013</h3>
  <h4>Why you should use Python 3 for text processing</h4>

  <p>Slides: <a href= "https://speakerdeck.com/pyconslides/why-you-should-use-python-3-for-text-processing-by-david-mertz">
https://speakerdeck.com/pyconslides/why-you-should-use-python-3-for-text-processing-by-david-mertz</a></p>

  <p>Video: <a href=
  "http://pyvideo.org/video/1704/why-you-should-use-python-3-for-text-processing">
  http://pyvideo.org/video/1704/why-you-should-use-python-3-for-text-processing</a></p>

  <p><a href="https://us.pycon.org/2013/speaker/profile/335/">David
  Mertz</a></p>

  <h5>Description</h5>

  <p>Python is a great language for text processing. Each new version of
  Python--but especially the 3.x series--has enhanced this strength of the
  language. String (and byte) objects have grown some handy methods and
  some built-in functions have improved or been added. More importantly,
  refinements and additions have been made to the standard library to cover
  the most common tasks in text processing.</p>

  <h5>Abstract</h5>

  <p>This talk, by its nature, will be a somewhat impressionistic review of
  nice-to-have improvements to text processing that have come to python--in
  part in the long time frame since my book on the topic, but with an
  emphasis on 3.x features.</p>

  <ol>
    <li>Improvements to collections help with many things, but seem to come
        up particularly often as nice ways to do text processing tasks: e.g.
        namedtuple; Counter; OrderedDict; defaultdict.</li>
    <li>Lots of improvements and rationalization of email package (mailbox
        too).</li>
    <li>Unicode handling--sometimes an important aspect of text
        processing--remains unwieldy, but has at least entered the domain of
        "possible to do right" (usually).</li>
    <li>Codecs improvements</li>
    <li>Relatively old but continues to improve: textwrap.</li>
    <li>ElementTree as standard library high-level option for XML handling
        (with various tweaks in 3.x version).</li>
    <li>str.format(); technically back ported to 2.x also, but a good
        option that wasn't in historical python versions.</li>
    <li>Miscellaneous improvements to datetime.</li>
    <li>logging has become good enough that it should be a standard tool
        for logging (also backported generally).</li>
    <li>hashlib</li>
    <li>csv improvements.</li>
    <li>Not only in 3.x, but json as a standard module is wonderful for
        serialization and data sharing.</li>
    <li>Ancient but little known tip: use str.startswith([list,of,values]).</li>
  </ol>

<hr/>
<!-- ====================================================================== -->

</body>
</html>
